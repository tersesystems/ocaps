<!DOCTYPE html>
<html>
<head>
<title>Security in Scala: Refined Typed and Object Capabilities</title>
<meta charset="utf-8">
<style type="text/css">
  @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
  @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
  @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

  body { font-family: 'Droid Serif', 'Helvetica'; }
  h1, h2, h3 {
    font-family: 'Yanone Kaffeesatz', 'Gill Sans';
    font-weight: normal;
  }
  .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }

      //.remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
</style>
<!-- https://github.com/gnab/remark/wiki/Adding-graphs-via-Mermaid -->
<!-- note https://github.com/knsv/mermaid/issues/360 -->
<link rel="stylesheet" href="mermaid.min.css">
</head>
<body>
<textarea id="source">
class: center, middle

# Security In Scala
### Refined Types and Object Capabilities
Will Sargent â€¢ `@will_sargent`

???
- notes here
- see https://remarkjs.com/#1

---
class: center, middle

## Lots to cover, so this will be high level and fast!

.footnote[(There will room for questions at the end)]
---
class: center, middle, inverse

# What is Security in Scala?

---
class: center, middle

   Reject harmful input.

   Isolate resources.

   Deny functionality to attackers.

---
### Security In Scala

#### Security Decisions

  - Validation - deciding what is valid

  - Abstraction - deciding what should be visible

  - Encapsulation - deciding what should be hidden

  - Access Control - deciding what is forbidden

???
If something is invalid, it can't be used.
If something is visible, then why?
If something is hidden, then it can't be exposed.
Access Control is obvious.

---
### Security In Scala

#### Security Decisions

  - Validation - deciding what is valid

  - Abstraction - deciding what should be visible

  - Encapsulation - deciding what should be hidden

  - Access Control - deciding what is forbidden

#### Security Tools

  - Refinement Types - validates raw input

  - Capabilities - tight abstraction & encapsulation & revocable access

  - Dynamic Sealing - flexible information hiding

  - Membranes - operational isolation

---
class: center, middle, inverse
# What are Refinement Types?

---
class: center, middle

Refinement Types are raw types that obey predicates.

---
### Refinement Types

#### Description

  - Examples of raw types: `String`, `Boolean`, `Character`, `Int`, Collection API.

  - Raw types are unconstrained, and could contain invalid or harmful input.

  - In particular, String can contain **anything**.

  - Type `ZipCode` is a `String` with predicate "5 numeric characters".

  - Isolation of types -- you *only* get `ZipCode` if you validated for it.

---
### Refinement Types

#### Description

  - Examples of raw types: `String`, `Boolean`, `Character`, `Int`, Collection API.

  - Raw types are unconstrained, and could contain invalid or harmful input.

  - In particular, String can contain **anything**.

  - Type `ZipCode` is a `String` with predicate "5 numeric characters".

  - Isolation of types -- you *only* get `ZipCode` if you validated for it.

#### Refined Library

  - refined: simple refinement types for Scala

  - `libraryDependencies += "eu.timepit" %% "refined" % "0.9.0"`

  - [https://github.com/fthomas/refined](https://github.com/fthomas/refined)

---
#### Refinement Types Example

```tut
import eu.timepit.refined._
import eu.timepit.refined.api.Refined
import eu.timepit.refined.string._
import eu.timepit.refined.auto._

type ZipCode = String Refined MatchesRegex[W.`"""\\d{5}"""`.T]

val x = "94111"
val v: Either[String, ZipCode] = refineV(x)
```

---
class: center, middle, inverse

# What are Capabilities?

---
class: center, middle

A capability is a security primitive that gives authority by reference.

Authority is sufficient justification to affect a resource.

---

### Defining Capabilities in Scala

- In Scala:

  - A resource is an object with some sensitive fields and/or methods.

  - A capability is a reference to an object that can affect the resource.

- Distinct from OOP!

    - OOP is all about accessibility through abstraction.

    - Capabilities are all about inaccessability through encapsulation.

---
### Capability Example

- We have a `Document` object, which has a `name` field anyone can change.

- We want expose the ability to change the name as a capability.

---

### Before

```scala
final class Document(var name: String) {
  override def toString: String = s"Document($name)"
}
```

---
### Document

```scala
final class Document(private var name: String) {
  private object capabilities {
    val nameChanger = new Document.NameChanger {
      override def changeName(newName: String): Unit = {
        name = newName
      }
    }
  }
  override def toString: String = s"Document($name)"
}
```

---
### Define NameChanger

```scala
object Document {
  sealed trait NameChanger {
    def changeName(name: String): Unit
  }

  class Access private {
    def nameChanger(doc: Document): NameChanger = {
      doc.capabilities.nameChanger
    }
  }
}
```

---
### Usage

```scala
val document = new Document("will")
val access = new Document.Access()
val nameChanger = access.nameChanger(document)
nameChanger.changeName("steve")
println(s"result = $document")
```

---
# Isolation of Objects

* `nameChanger` has authority to change the name of Document object (resource)
* The only way to reach `nameChanger` is through `Access`
* This is a "root level" capability!  Normally you wrap this in revocable.

---
# More Realistic Example

* We've got a standard CRUD `ItemRepository` object as the resource.
* By definition, everyone has access to create, read, update, and delete!
* Principal of Least Authority says "be careful when dispensing power"
* Through capabilities, we can have fine grained access control.

---
# ItemRepository Capabilities

```scala
object ItemRepository {
  trait Finder[F[_]] {
    def find(id: UUID): F[Option[Item]]
  }

  trait Updater[F[_]] {
    def update(item: Item): F[UpdateResult]
  }

  case class UpdateResult(message: String)

  class Access {
    def finder(repo: ItemRepository): Finder[Id] = repo.capabilities.finder
    def updater(repo: ItemRepository): Updater[Id] = repo.capabilities.updater
  }
}
```

---
# ItemRepository Capabilities

```scala
class ItemRepository {
  import ItemRepository._
  private def find(id: UUID): Option[Item] = items.find(_.id == id)
  private def update(u: Item): UpdateResult = UpdateResult(s"item $u updated")
  private object capabilities {
    val finder: Finder[Id] = new Finder[Id]() {
      override def find(id: UUID) = ItemRepository.this.find(id)
    }
    val updater: Updater[Id] = new Updater[Id]() {
      override def update(item: Item) = ItemRepository.this.update(item)
    }
  }
}
```

---
### Revocation

* Access to a capability can be through a delegate with conditional access
* `ocaps` implements macros and utility classes for revocation
* `Revoker`: `revoker.revoke()` destroys access
* `Revocable`: contains delegate and `Revoker`

---
# Revocable

```scala
import ocaps._
import ocaps.macros._
import ItemRepository._

val Revocable(revocableFinder, revoker) = revocable[Finder](finder)
revoker.revoke()
revocableFinder.find(ID) // throws RevokedException!
```

---
### Too Much To Talk About!

* *Composition*: compose two capabilities together
* *Attenuation*: tear out a capability from a composed one
* *Modulation*: set up before/after hooks on capability
* *Expiration*: use modulation/revocation for time/use based capabilities.

.footnote[Please see https://wsargent.github.io/ocaps/guide/index.html for all the above]
---
class: center, middle

# What is Dynamic Sealing?

---
## Dynamic Sealing

* Java gives you `private`, `protected` access modifiers
* Scala gives you `private[Outer]` access modifiers
* Dynamic Sealing allows you to have `private` between unrelated objects
* Extremely useful in capability context!

.footnote[Protection in programming languages Morris Jr., CACM 1973]
---
## Dynamic Sealing

* Brand consists of `sealer` and `unsealer` functions.
* Using a sealer produces a `Brand.Box` which is sealed
* Item is only accessible through `unsealer` function

---
# Dynamic Sealing Example

```scala
import ocaps.Brand
case class Food(name: String)
case class Can(food: Brand.Box[Food])

class CanOpener(unsealer: Brand.Unsealer[Food]) {
  def open(can: Can): Food = {
    unsealer(can.food).get // throws exception if we did not seal this
  }
}
```

---
# Dynamic Sealing Example

```scala
val (sealer, unsealer) = Brand.create[Food]("canned food").tuple
val canOfSpam: Can = Can(sealer(Food("spam")))

val cannedFood: Brand.Box[Food] = canOfSpam.food
println(s"food = ${canOfSpam.food.toString}") // DOES NOT WORK
val canOpener = new CanOpener(unsealer)

// We need both Can and CanOpener to unseal.
def openCan(can: Can, canOpener: CanOpener) = {
  val food: Food = canOpener.open(can)
  println(s"food = $food") // WORKS
}

openCan(canOfSpam, canOpener)
```

---
# Why use dynamic sealing?

* Isolation in potentially public scope, i.e. DI frameworks / Messages
* Great for sealing capabilities, `Access`, DBConnection objects
* Signing/Attestation (make the unsealer publically available)
* Encryption (make the sealer pubically available)

---
class: center, middle

# Membranes

---
# What are Membranes?

* Transitively enforce a policy on all commmunication
* All arguments and methods are "wrapped" with membrane and cannot escape
* Commonly used in sandboxes for "uncooperative revocation"
* Tough to do in JVM, using ByteBuddy interceptors is best avenue
* HOWEVER...

.footnote[Edward Z. Yang, [What Is A Membrane?](http://blog.ezyang.com/2013/03/what-is-a-membran/)]

---
# Permeable Membrane

* ...if you are willing to assume "cooperative revocation", then `PermeableMembrane` is for you.
* `ocaps` provides `PermeableMembrane` and `RevokerMembrane` out of the box
* You use a dependently typed effect on the membrane, and can functionally compose <it class=""></it>

---
# Membrane Definition

```scala
object Location {
  trait LocaleReader[F[_]] {
    def locale: F[Locale]
  }

  trait TimeZoneReader[F[_]] {
    def timeZone: F[TimeZone]
  }

  class MembraneAccess(membrane: PermeableMembrane) {
    type Wrapper[+A] = membrane.Wrapper[A]

    def localeReader(location: Location): LocaleReader[Wrapper] = {
      new LocaleReader[Wrapper] {
        override def locale: Wrapper[Locale] = {
          membrane.wrap(location.capabilities.localeReader.locale)
        }
      }
    }

    def timeZoneReader(location: Location): TimeZoneReader[Wrapper] = {
      new TimeZoneReader[Wrapper] {
        override def timeZone: Wrapper[TimeZone] = {
          membrane.wrap(location.capabilities.timeZoneReader.timeZone)
        }
      }
    }
  }
}
```

???
import java.util._

class Location(locale: Locale, timeZone: TimeZone) {
  private object capabilities {
    def localeReader: Location.LocaleReader[Id] = new Location.LocaleReader[Id] {
      override def locale: Locale = Location.this.locale
    }

    def timeZoneReader: Location.TimeZoneReader[Id] = new Location.TimeZoneReader[Id] {
      override def timeZone: TimeZone = Location.this.timeZone
    }
  }
}

---
# PermeableMembrane Usage

```scala
val m = RevokerMembrane()
val location = new Location(Locale.US, TimeZone.getTimeZone("PST"))
val access = new Location.MembraneAccess(m)

val dryLocale: Location.LocaleReader[access.Wrapper] = access.localeReader(location)
val dryTimeZone:  Location.TimeZoneReader[access.Wrapper] = access.timeZoneReader(location)

val format: access.Wrapper[String] = for {
  timeZone <- dryTimeZone.timeZone
  locale <- dryLocale.locale
} yield {
  ZonedDateTime.now(timeZone.toZoneId)
    .format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL)
      .withLocale(locale))
}

// Uncomment
// m.revoke()

// Break out the membrane
format.get
```

---
## Questions!

---
class: center, middle

# Thanks!
Code and guide at [https://wsargent.github.io/ocaps/](https://wsargent.github.io/ocaps/)


 </textarea>
    <script src="mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
