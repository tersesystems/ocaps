{"docs":[{"location":"/guide/notes.html","text":"","title":"README"},{"location":"/guide/notes.html#readme","text":"","title":"README"},{"location":"/guide/notes.html#capabilities","text":"A capability is a single thing that can access protected areas of a resource and authorizes some kind of access to it through reference. Capabilities can be implemented in object oriented programming languages, at which point they are called “object capability” systems, or “ocap” for short.\nThis doesn’t mean much by itself. So, say you have a class Foo, with a private method.\nfinal class Foo(name: String) {\n  private def privateDoTheThing(): Unit = {\n    println(s\"$name.doTheThing()\")\n  }\n}\nYou want to have other users of this class be able to call the private method, but only on a case by case basis.\nInstead of making the method public or protected, you can expose another class that does have access and a reference to that private method. We’ll call this Foo.Doer.\nobject Foo {\n  trait Doer {\n    def doTheThing(): Unit\n  }\n}\nNow, because we can use Scala’s access qualifiers and the trait is inside the companion object, we can create an instance of Foo.Doer by closing over Foo:\nfinal class Foo(name: String) {\n  private def privateDoTheThing(): Unit = {\n    println(s\"$name.doTheThing()\")\n  }\n\n  private[Foo] object capabilities {\n    val doer: Foo.Doer = new Foo.Doer {\n      override def doTheThing(): Unit = Foo.this.privateDoTheThing()\n    }\n  }\n}\nAnd now we have a capability. We can expose the capabilities of Foo through Access.\nimport scala.util.{Success, Try}\n\nfinal class Foo(name: String) {\n  private def privateDoTheThing(): Unit = {\n    println(s\"$name.doTheThing()\")\n  }\n\n  private[Foo] object capabilities {\n    val doer: Foo.Doer = new Foo.Doer {\n      override def doTheThing(): Unit = Foo.this.privateDoTheThing()\n    }\n  }\n}\n\nobject Foo {\n\n  trait Doer {\n    def doTheThing(): Unit\n  }\n\n  class Access {\n    def doer(foo: Foo) = foo.capabilities.doer\n  }\n}\nAnd then try it out:\nobject Main {\n  def main(args: Array[String]): Unit = {\n    val access = new Foo.Access()\n\n    val foo = new Foo(\"foo\")\n\n    val doer = access.doer(foo)\n    doer.doTheThing()\n  }\n}\nAnd we have a capability.\nA capability is a security primitive. It doesn’t look like much by itself. Then again, object oriented programming starts with a single object. Functional programming starts with a single function. The power in these systems comes from being able to build and compose powerful structures out of these primitives.\nSo, now that there’s a Foo.Doer capability, we can pass around references to that capability. Access to the reference gives a caller the authority to call the private method on Foo. Also note capability is instance based, so access to one Foo instance doesn’t mean you have access in general.\nval foo1 = new Foo(\"foo1\")\nval doer1 = foo1.capabilities.doer\nval foo2 = new Foo(\"foo2\")\nval doer2 = foo2.capabilities.doer\n\nval classWithFoo1Authority = new SomeClassThatWantsToDoThings(doer1)\nclassWithFoo1Authority.doThings() // uses doer1 to access foo1 private method\n\nval classWithFoo2Authority = new SomeClassThatWantsToDoThings(doer2)\nclassWithFoo2Authority.doThings() // uses doer2 to access foo2 private method\n\nval classWithNoAuthority = new SomeClassThatWantsToDoThings()\nclassWithNoAuthority.doThings() // whoops\nNote that although we’ve made the capability a subtype of Foo here, the capability can also enrich or define semantic control over a resource that wasn’t there before. Take the example of an Akka actor, which can receive any method:\nval actorRef = actorSystem.actorOf(Props(FooActor.class))\nval doer = new Doer {\n  def doTheThing(): Unit = actorRef ! DoTheThing\n}\nBy exposing the Doer capability instead of the ActorRef, callers now have type-safe access to functionality of the Actor, without being directly exposed to Akka itself.\nNote that although capabilities may look like functions, and in fact could be replaced as a function, they are objects, consisting of traits and classes which may have several methods. For example, a Writer capability could consist of several means of writing:\ntrait Writer {\n  def bufferedWriter(): java.io.BufferedWriter\n  def outputStream(): java.io.OutputStream\n}\nThere is a conceptual difference as well. Functions are not only anonymous, but are also public. It’s a common pattern to switch between a function and a wrapper type, for instance:\ntrait FooBarConverter extends Foo => Bar\n\nobject FooBarConverter {\n  def apply(f: Foo => Bar): FooBarConverter = new FooBarConverter {\n    override def apply(foo: Foo): Bar = f(foo)\n  }\n}\n\nval converter = FooBarConverter(foo => bar)\nThis does not qualify as a capability, because there is no privileged access to the function that can only be referenced through the converter.","title":"Capabilities"},{"location":"/guide/notes.html#why-this-works","text":"Because Scala qualifiers are awesome.\nhttp://jesperdj.com/2016/01/08/scala-access-modifiers-and-qualifiers-in-detail/","title":"Why this works"},{"location":"/guide/notes.html#how-to-assign-capabilities","text":"Generally, you want to do an authorization check as close as possible to the execution of the capability, use the capability in context, and then revoke it.\nOnly ask for a capability when you know you’re going to use it. Keep it short. Keep it focused.\nThere is a category of attack called Time of Check/Time of Use (TOCTOU), where the longer the period between a check made for the purposes of an operation and the actual operation itself the more opportunity there is for an attacker to “sneak in” under the hood.\nThere’s another attack called the “Confused Deputy” problem, where the more expansive the context of the authority, the more likely the authority is likely to be misused or delegated.\nCapability Myths Demolished\nDesignation inseperable from authority Deputies cannot be confused by authority-less designators There are no ambient authorities Authorities arrive in contexts of requests Subjects can locally identify authorities","title":"How to assign capabilities"},{"location":"/guide/notes.html#the-downcast-attack","text":"If you use structural types or AOP style mixins, then you may end up with downcasting to a specific type, which could expose your data.\nThis is a bit abstract, so it’s worth giving an example.\nclass Force {\n  private object capabilities {}\n}\n\nobject Force {\n  trait JediCapability {\n    def cleanRoom(): CleanRoomResults = ???\n  }\n    \n  trait SithCapability {\n    def forcePush(): ForcePushResults = ???\n    def choke(): ChokeResults = ???\n  }\n    \n  trait ForceCapability extends JediCapability with SithCapability\n    \n  trait Jedi {\n    def useTheForceWisely(jediPowers: JediCapability): Unit\n  }\n}\nOkay, let’s try it out.\nval theForce = new Force.ForceCapability\nval luke = new Jedi {\n  def useTheForceWisely(jediPowers: JediCapability) = {\n    jediPowers.cleanRoom()\n  }\n}\nluke.useTheForceWisely(theForce)\nLooks good! What could go wrong?\nval kylo = new Jedi {\n  override def useTheForceWisely(jediPowers: JediCapability) {\n    val sithPowers = jediPowers.asInstanceOf[SithCapability]\n    sithPowers.forcePush() // MUA HA HA\n  }\n}\nWhoops.\nWhat you need to do instead is never to subtype a capability if you can help it. Instead, close over capabilities to make them safe, and if you have fields make them all private.\nclass Force {\n   val jediPowers = new JediCapability {\n      def cleanRoom() = Force.this.cleanRoom()\n   }\n\n  val sithPowers = new SithCapability {\n    def forcePush() = Force.this.forcePush()\n    def choke() = Force.this.choke()\n  }\n}","title":"The Downcast Attack"},{"location":"/guide/notes.html#the-reflection-attack","text":"There’s another means by which callers can get a reference from a class that they should not be allowed to have: through reflection.\nYou can open up any field in the JVM using setAccessible, and you can monkeypatch any field or method with your own implementation using Unsafe.putObject. This can lead to truly horrifying results, i.e.\nimport java.lang.reflect.*;\n\npublic class EverythingIsTrue {\n   static void setFinalStatic(Field field, Object newValue) throws Exception {\n      field.setAccessible(true);\n\n      Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n      modifiersField.setAccessible(true);\n      modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n\n      field.set(null, newValue);\n   }\n   public static void main(String args[]) throws Exception {      \n      setFinalStatic(Boolean.class.getField(\"FALSE\"), true);\n\n      System.out.format(\"Everything is %s\", false); // \"Everything is true\"\n   }\n}\nNeedless to say, this disrupts the capability model, as any private reference can be made public, traversed through reflection, and monkeypatched.\nIn theory, you can set a security manager on the JVM, but that also comes with caveats. A full discussion is out of scope here, but Java 9 goes a long way to limiting setAccessible in conjunction with the module system","title":"The Reflection Attack"},{"location":"/guide/notes.html#stages-in-capabilities","text":"","title":"Stages in Capabilities"},{"location":"/guide/notes.html#custom-policies-on-capabilities","text":"We can define custom policies on capabilities, like a OneTimeUse[A], or a GoodForFiveMinutes[A] thing. We should be able to do this regardless of the capability.\nDeclarative Policies for Capability Control The need for capability policies https://types.cs.washington.edu/ftfjp2013/preprints/a6-Drossopoulou.pdf How to break the bank: Semantics of Capability Policies http://www.doc.ic.ac.uk/~scd/iFM_Caps.pdf Towards Capability Policy Specification and Verification https://www.researchgate.net/profile/Sophia_Drossopoulou/publication/261214232_Towards_Capability_Policy_Specification_and_Verification/links/00b7d5339827125ac2000000.pdf Restricted delegation in Haskell can be used with refined types to limit to members of a type Dependent types to restrict delegation options to sprcific people / resources\nAccess control policies restrict which components may use a given capability.\nIntegrity policies restrict which components may influence the use of a capability.\nWe demonstrate that standard language-based techniques can soundly enforce these policies (contracts and a security type system respectively).\nTODO Is it possible to implement HORTON through monads and additional info on capabilities?","title":"Custom policies on capabilities"},{"location":"/guide/notes.html#capabilities-and-effects","text":"In other words, it’s not just Membrane.\n“You get to flatmap this ONCE.” Give a demo. Love that side-effect.\nDesigning with Capabilities\nExisting systems conflate authentication and access decision pieces (presenting authentication when making request)\nRob Norris: An effect is whatever distinguishes F[A] from A.","title":"Capabilities and Effects"},{"location":"/guide/notes.html#capabilities-as-gatekeepers-to-resources","text":"","title":"Capabilities as gatekeepers to resources"},{"location":"/guide/notes.html#capabilities-vs-circuitbreakers","text":"","title":"Capabilities vs CircuitBreakers"},{"location":"/guide/notes.html#revocation-and-caretakers","text":"One common pattern to use with capabilities is to revoke access to the protected resource. This is done through the revoker trait.\ntrait revoker {\n  def revoke(): Unit\n}\nProviding a capability with a revoker is done through a Revocable pattern, which exposes the caretaker with the capability.\ntrait Revocable[C] {\n  def capability: C\n  def revoker: revoker\n}\nThe caretaker provides a capability which closes over the previous one, but which can be revoked at any time, causing an exception to be thrown. Using Try is a good practice to incorporate, since capabilities are fungible:\nThe Caretaker has a provider function which will call out to the underlying doer on every method invocation.\nval revocable: Revocable[Foo.Doer] = Foo.Doer.caretaker(doer)\nval revokerDoer: Foo.Doer = caretaker.get\nval revoker = caretaker.revoker\n\nval success = revokerDoer.doTheThing() // returns Success!\nrevoker.revoke() // shut off access through the provider\nval failure = revokerDoer.doTheThing() // returns Failure(RevokedException)\nThe caller has a reference to the revoked capability still, but it’s useless after revocation, because every call will return Failure with RevokedException. A caller who wants access will have to recover by asking for another capability.\nRevocation is extremely flexible. It’s possible to revoke capabilities based on the number of times the capability is invoked. Or after a fixed amount of time, or based on rule based suspicion.\nclass JediMaster(jediPowers: JediCapability) {\n  \n  def cleanYourRoom(jedi: Jedi): Unit = {\n    try {\n      val Caretaker(revokerJediPowers, revoker) = Jedi.caretaker(jediPowers)\n      // it shouldn't take more than 5 minutes to clean a room.\n      after(5 minutes, () => revoker.revoke()) \n      user.useTheForceWisely(revokerJediPowers) \n    } finally {\n      revoker.revoke()\n    }\n  }\n}\n\nval yoda = new JediMaster(force.jediPowers)\nyoda.cleanYourRoom(luke)\nNow, the program is safer on several levels. Yoda only has Jedi Powers, can delegate only the powers he has, and can revoke delegation both on completion or on suspicion.","title":"Revocation and Caretakers"},{"location":"/guide/notes.html#loggers","text":"object Foo {\n  object Doer {\n    // Note there's no external reference to the external FooCapability here\n    def logger(provider: => Foo.Doer): Foo.Doer = new Foo.Doer {\n      override def doTheThing(): Unit = {\n        println(\"about to do the thing\")\n        provider.doTheThing()\n      }\n    }\n  }\n}\n\nval foo = new Foo(\"foo\")\nval doer = foo.capabilities.doer\nval loggingDoer = Foo.Doer.logger(doer)","title":"Loggers"},{"location":"/guide/notes.html#attenuation","text":"reducing a capability’s scope of authority\nExample: An OCap may have access to a computer’s file system.\nUsing attenuation, we can return an intermediary capability of just a particular file or subdirectory. Read-only access useful for packaging access to existing, non-capablity oriented world into capabilities mediate access to network communications limit connections to particular domains allow applications to be securely distributed across datacenters without enabling them to talk to arbitrary hosts on the internet – the sort of thing that would normally be regulated by firewall configuration, but without the operational overhead or administrative inconvenience","title":"Attenuation"},{"location":"/guide/notes.html#abstraction","text":"Packing lower level capabilities into more convenient APIs example: package read-only file cap into an input steram object example: Unix passwd command is an example of abstracting lower level details of file access and data formats","title":"Abstraction"},{"location":"/guide/notes.html#combination","text":"Uses two or more capabilities together to create a new capability to some specific joint functionality, or create something truly new Example: In a Cap OS for mobile smartphones, having a combined capability composed of the authority to capture images with camera, the authority to obtain position with GPS, the authority to read system clock.","title":"Combination"},{"location":"/guide/notes.html#sealer-unsealer","text":"So bob.foo(carol) means that bob has the reference to carol now. In a membrane, we’re not only wrapping access to carol, but also to bob???\nbob.foo(carol) => membrane(bob).foo(membrane(carol))\nThis doesn’t make much sense, so let’s use the jedi analogy again:\nkylo.usePowersWisely(jediPowers)\nEven if Kylo attempts to hand his Jedi powers off to everyone else, we can revoke them.\nEvery single parameter has to be wrapped in in something that is revoker. So Int => Membrane[Int] etc. This may be not workable in Scala, and I don’t doubt you could bypass it.\n// https://gist.github.com/mbedward/6e3dbb232bafec0792ba // https://github.com/adamw/quicklens/blob/master/quicklens/src/main/scala/com/softwaremill/quicklens/QuicklensMacros.scala // https://github.com/wix/accord/blob/master/core/src/main/scala/com/wix/accord/transform/ValidationTransform.scala // http://www.strongtyped.io/blog/2014/05/23/case-class-related-macros/ // http://blog.scottlogic.com/2013/06/07/scala-macros-part-3.html // http://blog.echo.sh/2013/11/04/exploring-scala-macros-map-to-case-class-conversion.html // https://github.com/echojc/scala-macro-template // https://blog.scalac.io/2016/05/26/simple-types-in-play.html // https://stackoverflow.com/questions/25188440/applying-type-constructors-to-generated-type-parameters-with-scala-macros","title":"Sealer/Unsealer"},{"location":"/guide/notes.html#other-works","text":"","title":"Other works"},{"location":"/guide/notes.html#capability-patterns-papers","text":"What are Capabilities Analysing Object-Capability Patterns With Murϕ http://erights.org/talks/thesis/index.html Analysing the Security Properties of Object-Capability Patterns Patterns of Safe Collaboration Language and Framework Support for Reviewably-Secure Software Systems Towards First Class References as a Security Infrastructure in Dynamically-Typed Languages Capability Myths Demolished Robust Composition: Towards a Unified Approach to Access Control and Concurrency Control LaCasa PDF Emily The Structure of Authority: Why Security Is not a Separable Concern https://www.cs.ox.ac.uk/files/2690/AOCS.pdf https://classes.soe.ucsc.edu/cmps203/Winter12/static/markm-ocap.pdf https://types.cs.washington.edu/ftfjp2013/preprints/a6-Drossopoulou.pdf http://www.doc.ic.ac.uk/~scd/iFM_Caps.pdf http://www.erights.org/talks/asian03/paradigm-revised.pdf http://www.erights.org/elib/capability/deadman.html\nLightweight static capaiblities\nbasically treating types as capabilities. This is “strongly” typed programming so the refined type library is already ahead. There’s nothing new here.\nhttps://github.com/changlinli/types_presentation_slides/blob/v0.2.0/slides.md\nhttp://okmij.org/ftp/papers/lightweight-static-capabilities.pdf https://tfp2016.org/papers/TFP_2016_paper_22.pdf http://lambda-the-ultimate.org/node/1635 https://www.youtube.com/watch?v=Ankp-DtKFmI","title":"Capability Patterns Papers"},{"location":"/guide/notes.html#blog-posts","text":"http://joeduffyblog.com/2015/11/10/objects-as-secure-capabilities/ https://fsharpforfunandprofit.com/posts/capability-based-security/ https://fsharpforfunandprofit.com/posts/capability-based-security-2/ https://fsharpforfunandprofit.com/posts/capability-based-security-3/ Capability Patterns http://www.cap-lore.com/CapTheory/ http://erights.org/elib/capability/index.html http://wiki.c2.com/?CapabilityOrientedProgramming https://github.com/dckc/awesome-ocap https://github.com/GravityNetwork/Gravity/wiki/Reading-List","title":"Blog Posts"},{"location":"/guide/notes.html#capability-patterns","text":"What are Capabilites? (MOST USEFUL INTRO) Capability Patterns (SO MUCH) https://github.com/hierophantos/capable http://wiki.c2.com/?FacetPattern http://wiki.c2.com/?CaretakerPattern http://wiki.c2.com/?TwoKindsOfCapabilities http://wiki.c2.com/?BuildSecurityAbstractionsIntoCapabilities https://blog.acolyer.org/2016/02/16/capability-myths-demolished/","title":"Capability Patterns"},{"location":"/index.html","text":"","title":"ocaps"},{"location":"/index.html#ocaps","text":"ocaps is a library for working with object capabilities in Scala.\nRevoker / Revocable classes for revoking capabilities. Brand for sealing and unsealing capabilities PermeableMembrane for revocation as an effect. Macros for composition, attenuation, revocable and modulating capabilities. No libraries dependencies (other than scala-reflect)\nDocumentation can be found at https://wsargent.github.io/ocaps/\nExamples can be found at https://wsargent.github.io/ocaps/examples/\nA guide to object capabilities can be found at https://wsargent.github.io/ocaps/guide/\nSlides from Scaladays NYC 2018 are available here.","title":"ocaps"},{"location":"/running.html","text":"","title":"Running"},{"location":"/running.html#running","text":"The ocaps artifacts are available in https://bintray.com/wsargent/maven/ocaps-core.\nSource code is available in https://github.com/wsargent/ocaps. Issues can be added at https://github.com/wsargent/ocaps/issues.","title":"Running"},{"location":"/running.html#dependencies","text":"To add ocaps to your project, add the following resolver to build.sbt:\nresolvers += Resolver.bintrayRepo(\"wsargent\",\"maven\")\nAnd add the given library dependency in build.sbt:\nsbt libraryDependencies += \"ocaps\" %% \"ocaps\" % \"0.1.1-SNAPSHOT\" Maven <dependency>\n  <groupId>ocaps</groupId>\n  <artifactId>ocaps_2.12</artifactId>\n  <version>0.1.1-SNAPSHOT</version>\n</dependency> Gradle dependencies {\n  compile group: 'ocaps', name: 'ocaps_2.12', version: '0.1.1-SNAPSHOT'\n}","title":"Dependencies"},{"location":"/running.html#imports","text":"To import the ocaps library classes, please add the following to your Scala files:\nimport ocaps._\nimport ocaps.macros._","title":"Imports"},{"location":"/examples/index.html","text":"","title":"Examples"},{"location":"/examples/index.html#examples","text":"This is a series of examples showing capabilities in action using ocaps.\nNote If you are not familiar with capabilities, please read through the guide for a more in-depth explanation.","title":"Examples"},{"location":"/examples/index.html#imports","text":"All the examples given rely on the following imports:\nimport ocaps._\nimport ocaps.macros._","title":"Imports"},{"location":"/examples/index.html#construction","text":"This section shows creation of capabilities and direct use.\nConstruction Construction with Effects Construction with Subtypes","title":"Construction"},{"location":"/examples/index.html#structural-patterns","text":"This section shows structural patterns that do not change behavior.\nComposition Attenuation","title":"Structural Patterns"},{"location":"/examples/index.html#behavioral-patterns","text":"This section shows patterns that change the behavior of capabilities, typically adding side effects or blocking execution completely.\nModulation Revocation Expiration","title":"Behavioral Patterns"},{"location":"/examples/index.html#operational-patterns","text":"This section shows capabilities used together.\nAmplification Abstraction","title":"Operational Patterns"},{"location":"/examples/index.html#authorization-patterns","text":"This section shows capabilities in the context of authorization and delegation.\nDelegation Gatekeeper","title":"Authorization Patterns"},{"location":"/examples/index.html#confinement-patterns","text":"This section shows capabilities being rendered inaccessible or made accessible through a membrane.\nDynamic Sealing Membrane","title":"Confinement Patterns"},{"location":"/examples/construction.html","text":"","title":"Construction"},{"location":"/examples/construction.html#construction","text":"Constructing a capability in Scala is all about deciding what operations on a resource should be isolated and encapsulated with access control.","title":"Construction"},{"location":"/examples/construction.html#before","text":"We’ll start by showing a class that has methods that we want to capabilities. Here’s a Document class that lets you change the name.\nobject Before {\n\n  final class Document(var name: String) {\n    override def toString: String = s\"Document($name)\"\n  }\n\n  def main(args: Array[String]): Unit = {\n    val document = new Document(\"will\")\n    document.name = \"steve\"\n    println(s\"Before: result = $document\")\n  }\n}\nSingle Abstract Method (SAM) traits, such as java.lang.Runnable and FunctionN are natural capabilities.\nHowever, anonymous functions typically don’t expose the domain, and don’t indicate sensitivity – one () => String looks much the same as another, so it’s harder to track where a capability is exposed. You can extend these to provided named traits that expose your domain functionality.\nFor example, we don’t want just anyone to be able to change the name, so we set up a NameChanger capability, which extends Function0.\nNote that these are “root level” capabilities – they are non-revocable, “private key” object references, so you typically want to wrap these in ocap.Revocable and hand out the revocable capability instead.","title":"Before"},{"location":"/examples/construction.html#construction-through-access","text":"Here’s what the code looks like after refactoring.\nobject AfterAmplification {\n\n  final class Document(private var name: String) {\n    private object capabilities {\n      val nameChanger = new Document.NameChanger {\n        override def changeName(newName: String): Unit = {\n          name = newName\n        }\n      }\n    }\n    override def toString: String = s\"Document($name)\"\n  }\n\n  object Document {\n    trait NameChanger {\n      def changeName(name: String): Unit\n    }\n\n    class Access {\n      def nameChanger(doc: Document): NameChanger = {\n        doc.capabilities.nameChanger\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val document = new Document(\"will\")\n    val access = new Document.Access()\n    val nameChanger = access.nameChanger(document)\n    nameChanger.changeName(\"steve\")\n    println(s\"AfterAmplification: result = $document\")\n  }\n}\nYou’ll note that access modifiers are used heavily here, and there’s an Access class which is involved in exposing the capability. When two (or more) objects are required to expose some extra functionality, it’s called amplification.\nThis Access class constructor is public here, but obviously anyone who has both Access and a resource will be able to expose capabilities, so you should protect your access appropriately. You can use dynamic sealing or Scala access modifiers to ensure access is tightly controlled.","title":"Construction Through Access"},{"location":"/examples/construction.html#effects","text":"The Access class also makes a good place to provide functional programming effects on capabilities. Please see the construction with effects example for more details.","title":"Effects"},{"location":"/examples/construction.html#subtypes","text":"You can create capabilities on abstract parent classes, and be able to use subtypes appropriately. Please see the construction with subtypes example for more details.","title":"Subtypes"},{"location":"/examples/construction.html#construction-through-composition","text":"There is another way to construct capabilities, which is through composition.\nobject AfterAttenuation {\n\n  final class Document(private var name: String) extends Document.NameChanger {\n    override def changeName(newName: String): Unit = {\n      name = newName\n    }\n    override def toString: String = s\"Document($name)\"\n  }\n\n  object Document {\n    trait NameChanger {\n      def changeName(name: String): Unit\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val document = new Document(\"will\")\n\n    // expose a single facet through attenuation\n    val nameChanger = new Document.NameChanger {\n      override def changeName(name: String): Unit = document.changeName(name)\n    }\n    nameChanger.changeName(\"steve\")\n    println(s\"AfterAttenuation: result = $document\")\n  }\n}\nIn this construction, having access to the resource means having access to all of its capabilities, because the resource implements the capabilities directly as traits.\nI don’t like this construction, because you need to keep access to the resource itself tightly constrained.\nIf you want to expose a capability by itself, then you do so by exposing a single capability through attenuation.","title":"Construction Through Composition"},{"location":"/examples/effects.html","text":"","title":"Construction with Effects"},{"location":"/examples/effects.html#construction-with-effects","text":"object Effects {\n  type Id[A] = A\n\n  final class Document(private var name: String) {\n    import Document._\n    private object capabilities {\n      val nameChanger: NameChanger[Id] = new NameChanger[Id] {\n        override def changeName(newName: String): Unit = {\n          name = newName\n        }\n      }\n    }\n    override def toString: String = s\"Document($name)\"\n  }\n\n  object Document {\n    trait NameChanger[F[_]] {\n      def changeName(name: String): F[Unit]\n    }\n\n    trait WithEffect[C[_[_]], F[_]] {\n      def apply(capability: C[Id]): C[F]\n    }\n\n    // The default \"no effect\" type Id[A] = A\n    implicit val idEffect: NameChanger WithEffect Id = new WithEffect[NameChanger, Id] {\n      override def apply(capability: NameChanger[Id]): NameChanger[Id] = identity(capability)\n    }\n\n    // Apply a \"Try\" effect to the capability\n    implicit val tryEffect: NameChanger WithEffect Try = new WithEffect[NameChanger, Try] {\n      override def apply(capability: NameChanger[Id]): NameChanger[Try] = new NameChanger[Try] {\n        override def changeName(name: String): Try[Unit] =  Try(capability.changeName(name))\n      }\n    }\n\n    class Access {\n      def nameChanger[F[_]](doc: Document)(implicit ev: NameChanger WithEffect F): NameChanger[F] = {\n        val effect = implicitly[NameChanger WithEffect F]\n        effect(doc.capabilities.nameChanger)\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val document = new Document(\"will\")\n    val access = new Document.Access()\n\n    val tryNameChanger = access.nameChanger[Try](document)\n    tryNameChanger.changeName(\"steve\") match {\n      case Success(_) =>\n        println(s\"result = $document\")\n      case Failure(ex) =>\n        println(s\"exception = $ex\")\n    }\n\n    // or...\n\n    val idNameChanger = access.nameChanger[Id](document)\n    idNameChanger.changeName(\"Will\")\n    println(s\"result = $document\")\n  }\n}","title":"Construction with Effects"},{"location":"/examples/subtypes.html","text":"","title":"Construction with Subtypes"},{"location":"/examples/subtypes.html#construction-with-subtypes","text":"This example shows how to create capabilities from an abstract base type. You can read Constructing Capabilities in the guide for more information.\nobject Subtypes {\n\n  import Fruit._\n\n  sealed trait FruitState\n\n  object FruitState {\n    case object Uneaten extends FruitState\n    case object Eaten extends FruitState\n  }\n\n  trait Fruit {\n    import Fruit._\n\n    private[this] var state: FruitState = FruitState.Uneaten\n\n    def currentState: FruitState = state\n\n    object capabilities {\n      val eater: Eater[Fruit.this.type] = new Eater[Fruit.this.type] {\n        def eat(): Fruit.this.type = {\n          Fruit.this.state match {\n            case FruitState.Uneaten =>\n              Fruit.this.state = FruitState.Eaten\n              Fruit.this\n\n            case FruitState.Eaten =>\n              throw new IllegalStateException(\"Already eaten!\")\n          }\n        }\n      }\n    }\n  }\n\n  object Fruit {\n\n    trait Eater[+F <: Fruit] {\n      def eat(): F\n    }\n\n    object Eater {\n      def logger[F <: Fruit](eater: Eater[F]): Eater[F] = new Eater[F] {\n        override def eat(): F = {\n          println(\"about to do the thing\")\n          eater.eat()\n        }\n      }\n    }\n\n    class Access {\n      // Expose this capability raw, with no checks or anything.\n      def eater[F <: Fruit](fruit: F): Eater[F] = fruit.capabilities.eater\n    }\n  }\n\n  final class Apple extends Fruit {\n    override def toString: String = s\"Apple($currentState)\"\n  }\n\n  final class Pear extends Fruit {\n    override def toString: String = s\"Pear($currentState)\"\n  }\n\n  case class User(name: String, caps: Map[Fruit, Eater[_]] = Map.empty) {\n\n    def canEat[F <: Fruit](fruit: F, eater: Eater[F]): User = {\n      copy(caps = caps + (fruit -> eater))\n    }\n\n    def eats[F <: Fruit](fruit: F): Try[Option[F]] = {\n      val triedFruit = Try {\n        println(s\"${name} eating $fruit:\")\n\n        caps.get(fruit).map { eater: Eater[_] =>\n          val castEater = eater.asInstanceOf[Eater[F]] // Map strips off type info :-(\n          Eater.logger(castEater).eat()\n        }\n      }\n      println(s\"  $triedFruit\")\n      triedFruit\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n\n    val access = new Access\n    def grantEater[F <: Fruit](user: User, fruit: F): Eater[F] = {\n      access.eater(fruit)\n    }\n\n    var steve = User(\"steve\")\n    val apple = new Apple()\n    steve = steve.canEat(apple, grantEater(steve, apple))\n    val eatenApple: Try[Option[Apple]] = steve.eats(apple)\n    println(s\"steve's apple = $eatenApple\")\n\n    val apple2 = new Apple()\n    steve.eats(apple2)\n\n    var mutt = User(\"mutt\")\n\n    val pear = new Pear()\n    mutt = mutt.canEat(pear, grantEater(mutt, pear))\n    val eatenPear: Try[Option[Pear]] = mutt.eats(pear)\n    println(s\"mutt's pear = $eatenPear\")\n\n    val jeff = User(\"jeff\")\n    val pear2 = new Pear()\n    jeff.eats(pear2)\n  }\n}","title":"Construction with Subtypes"},{"location":"/examples/composition.html","text":"","title":"Composition"},{"location":"/examples/composition.html#composition","text":"This is an example of how capabilities are constructed.\nYou can read more in Constructing Capabilities section of the guide.\nimport ocaps.macros._\n\nobject Composition {\n\n  final class Foo(private var name: String) {\n    private object capabilities {\n      val doer: Foo.Doer = new Foo.Doer {\n        override def doTheThing(): Unit = {\n          println(s\"$name.doTheThing()\")\n        }\n      }\n      val changer: Foo.Changer = new Foo.Changer {\n        override def changeName(name: String): Foo.this.type = {\n          Foo.this.name = name\n          Foo.this\n        }\n      }\n    }\n  }\n\n  object Foo {\n    trait Doer {\n      def doTheThing(): Unit\n    }\n\n    trait Changer {\n      def changeName(name: String): Foo\n    }\n\n    trait Derper {\n      def derp(): Unit\n    }\n\n    class Access private {\n      def doer(foo: Foo): Doer = foo.capabilities.doer\n      def changer(foo: Foo): Changer = foo.capabilities.changer\n    }\n\n    object Access {\n      def apply(): Access = new Access\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    import Foo._\n    val access = Foo.Access()\n    val foo = new Foo(\"foo\")\n    val doer: Doer = access.doer(foo)\n    val changer: Changer = access.changer(foo)\n    val derper: Derper = new Derper {\n      override def derp(): Unit = println(\"derp!\")\n    }\n    val doerChangerDerper =\n      compose[Doer with Changer with Derper](doer, changer, derper)\n\n    // composition is often used when you want to return a \"set\" of capabilities after\n    // some authorization event has taken place, after which you can do some pattern matching\n    doerChangerDerper match {\n      case d: Derper =>\n        d.derp()\n    }\n\n    // this of course works with all of the compound types, but you can also use attenuation\n    // to pull out a particular capability.\n    val attenuatedChanger: Changer = doerChangerDerper match {\n      case c: Changer =>\n        attenuate[Changer](c)\n    }\n    attenuatedChanger.changeName(\"bar\")\n  }\n}","title":"Composition"},{"location":"/examples/attenuation.html","text":"","title":"Attenuation"},{"location":"/examples/attenuation.html#attenuation","text":"This is an example of modulation in ocaps. You can read Managing Capabilities in the guide for more information.\nimport ocaps.macros._\n\nobject Attenuation {\n\n  final class Foo(private var name: String) {\n    private object capabilities {\n      val doer: Foo.Doer = new Foo.Doer {\n        override def doTheThing(): Unit = {\n          println(s\"$name.doTheThing()\")\n        }\n      }\n      val changer: Foo.Changer = new Foo.Changer {\n        override def changeName(name: String): Foo.this.type = {\n          Foo.this.name = name\n          Foo.this\n        }\n      }\n    }\n  }\n\n  object Foo {\n\n    trait Doer {\n      def doTheThing(): Unit\n    }\n\n    trait Changer {\n      def changeName(name: String): Foo\n    }\n\n    trait Derper {\n      def derp(): Unit\n    }\n\n    class Access {\n      def doer(foo: Foo): Doer = foo.capabilities.doer\n      def changer(foo: Foo): Changer = foo.capabilities.changer\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    import Foo._\n\n    val access = new Access()\n    val foo = new Foo(\"foo\")\n\n    val doer: Doer = access.doer(foo)\n    val changer: Changer = access.changer(foo)\n    val derper: Derper = new Derper {\n      override def derp(): Unit = println(\"derp\")\n    }\n    val doerChangerDerper =\n      compose[Doer with Changer with Derper](doer, changer, derper)\n\n    // We want an attenuation that makes only Doer available\n    val castDoer: Doer = doerChangerDerper.asInstanceOf[Doer]\n    // But we can recover Derper capability here!\n    val doerAsDerper: Derper = castDoer.asInstanceOf[Derper]\n    // whoops :-(\n    doerAsDerper.derp()\n\n    // Attenuation doesn't use downcasting, is safe!\n    val attenuatedDoer: Doer = attenuate[Doer](doerChangerDerper)\n    try {\n      val downcastAttenuatedDerper = attenuatedDoer.asInstanceOf[Derper]\n      attenuatedDoer.doTheThing()\n    } catch {\n      case e: ClassCastException =>\n        println(\"Can't downcast to a different type using the macro!\")\n    }\n  }\n}","title":"Attenuation"},{"location":"/examples/modulation.html","text":"","title":"Modulation"},{"location":"/examples/modulation.html#modulation","text":"This is an example of modulation in ocaps. You can read Managing Capabilities in the guide for more information.\nimport ocaps.macros._\nimport org.slf4j.Logger\n\nimport scala.util.Try\n\nobject Modulation {\n  final case class Foo(private val name: String) {\n    private object capabilities {\n      val doer: Foo.Doer = new Foo.Doer {\n        override def doTheThing(): Int = {\n          42\n        }\n      }\n    }\n  }\n\n  object Foo {\n    trait Doer {\n      def doTheThing(): Int\n    }\n\n    class Access {\n      def doer(foo: Foo): Doer = foo.capabilities.doer\n    }\n  }\n\n  def loggingDoer(doer: Foo.Doer, logger: Logger): Foo.Doer = {\n    val before: String => Unit = methodName => {\n      logger.info(s\"$methodName: before call\")\n    }\n    val after: (String, Any) => Unit = (methodName, result) =>\n      logger.info(s\"$methodName: after returns $result\")\n    modulate[Foo.Doer](doer, before, after)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val access = new Foo.Access()\n    val foo = new Foo(\"foo\")\n    val doer = access.doer(foo)\n\n    val logger = org.slf4j.LoggerFactory.getLogger(\"modulation.Foo.Doer\")\n    val logDoer = loggingDoer(doer, logger)\n    val result1 = Try(logDoer.doTheThing())\n    println(s\"result after first call: $result1\")\n\n    val result2 = Try(logDoer.doTheThing())\n    println(s\"result after second call: $result2\")\n  }\n}","title":"Modulation"},{"location":"/examples/revocation.html","text":"","title":"Revocation"},{"location":"/examples/revocation.html#revocation","text":"This is an example of revocation in ocaps. You can read Managing Capabilities in the guide for more information.\nobject Revocation {\n\n  final class Foo(name: String) {\n    private def privateDoTheThing(): Unit = {\n      println(s\"$name.doTheThing()\")\n    }\n\n    private object capabilities {\n      import Foo._\n      val doer: Doer = new Doer {\n        override def doTheThing(): Unit = Foo.this.privateDoTheThing()\n      }\n    }\n  }\n\n  object Foo {\n    trait Doer {\n      def doTheThing(): Unit\n    }\n\n    object Doer {\n      def revocable(doer: Doer): Revocable[Doer] = {\n        Revocable(doer) { thunk =>\n          new Doer {\n            override def doTheThing(): Unit = thunk().doTheThing()\n          }\n        }\n      }\n    }\n\n    class Access {\n      def doer(foo: Foo): Doer = foo.capabilities.doer\n    }\n  }\n\n  import java.util.concurrent.TimeUnit._\n  import java.util.concurrent._\n\n  private val scheduler = Executors.newScheduledThreadPool(1)\n\n  // Guest has delegated authority to do the thing without having access to foo\n  class Guest(doer: Foo.Doer) {\n    def start(): Unit = {\n      // Keep doing the thing forever, every second.\n      val doTheThing: Runnable = new Runnable {\n        override def run(): Unit = {\n          try {\n            doer.doTheThing()\n          } catch {\n            case NonFatal(e) => println(\"Cannot do the thing!\")\n          }\n        }\n      }\n      scheduler.scheduleAtFixedRate(doTheThing, 0, 1L, SECONDS)\n    }\n  }\n\n  // Revoker doesn't know about capability, only has kill switch\n  class ScheduledRevoker(revoker: Revoker) {\n    def start(): Unit = {\n      // After three seconds, the admin decides to stop you doing the thing.\n      val adminRevoke: Runnable = new Runnable {\n        override def run(): Unit =  revoker.revoke()\n      }\n      scheduler.schedule(adminRevoke, 3L, SECONDS)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    import Foo._\n    val foo = new Foo(\"foo\")\n\n    val access = new Access\n    val doer = access.doer(foo)\n\n    // macro generates code equivalent to the `revocable` code above\n    //val Revocable(revocableDoer, revoker) = Foo.Doer.revocable(doer)\n    val Revocable(revocableDoer, revoker) = macros.revocable[Doer](doer)\n\n    new Guest(revocableDoer).start()\n    new ScheduledRevoker(revoker).start()\n\n    // After five seconds, exit program.\n    val shutdown: Runnable = new Runnable {\n      override def run(): Unit = scheduler.shutdown()\n    }\n    scheduler.schedule(shutdown, 5L, SECONDS)\n  }\n\n}","title":"Revocation"},{"location":"/examples/expiration.html","text":"","title":"Expiration"},{"location":"/examples/expiration.html#expiration","text":"Expiration combines modulation of a capability with revocation. Using modulation, a capability can make use of internal or external state to decide whether it should revoke access through an internal revoker.\nYou can read Managing Capabilities in the guide for more information.\nimport ocaps.macros._\nimport org.slf4j.Logger\n\nimport scala.util.Try\n\nobject Modulation {\n  final case class Foo(private val name: String) {\n    private object capabilities {\n      val doer: Foo.Doer = new Foo.Doer {\n        override def doTheThing(): Int = {\n          42\n        }\n      }\n    }\n  }\n\n  object Foo {\n    trait Doer {\n      def doTheThing(): Int\n    }\n\n    class Access {\n      def doer(foo: Foo): Doer = foo.capabilities.doer\n    }\n  }\n\n  def loggingDoer(doer: Foo.Doer, logger: Logger): Foo.Doer = {\n    val before: String => Unit = methodName => {\n      logger.info(s\"$methodName: before call\")\n    }\n    val after: (String, Any) => Unit = (methodName, result) =>\n      logger.info(s\"$methodName: after returns $result\")\n    modulate[Foo.Doer](doer, before, after)\n  }\n\n  def main(args: Array[String]): Unit = {\n    val access = new Foo.Access()\n    val foo = new Foo(\"foo\")\n    val doer = access.doer(foo)\n\n    val logger = org.slf4j.LoggerFactory.getLogger(\"modulation.Foo.Doer\")\n    val logDoer = loggingDoer(doer, logger)\n    val result1 = Try(logDoer.doTheThing())\n    println(s\"result after first call: $result1\")\n\n    val result2 = Try(logDoer.doTheThing())\n    println(s\"result after second call: $result2\")\n  }\n}","title":"Expiration"},{"location":"/examples/amplification.html","text":"","title":"Amplification"},{"location":"/examples/amplification.html#amplification","text":"Amplification is when two object references put together result in an ability to do something not possible if you don’t have references to both.\nTechnically, the Access pattern qualifies:\nobject Document {\n  trait NameChanger {\n    def changeName(name: String): Unit\n  }\n}\nobject Document {\n  trait NameChanger {\n    def changeName(name: String): Unit\n  }\n\n  class Access {\n    def nameChanger(doc: Document): NameChanger = {\n      doc.capabilities.nameChanger\n    }\n  }\n}\nBut amplification is more about bringing together independent objects. The canonical example is a can and can opener, brought together by dynamic sealing:\nimport ocaps._\n\nobject Amplification {\n\n  case class Food(name: String)\n\n  case class Can(food: Brand.Box[Food])\n\n  class CanOpener(unsealer: Brand.Unsealer[Food]) {\n    def open(can: Can): Food = {\n      unsealer(can.food).get\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    // We want to get at the food here.\n\n    val (sealer, unsealer) = Brand.create[Food](\"canned food\").tuple\n    val canOfSpam: Can = Can(sealer(Food(\"spam\")))\n\n    // The can by itself has the food, but we have no way to get to it\n    val cannedFood: Brand.Box[Food] = canOfSpam.food\n    println(s\"food = ${cannedFood.toString}\") // DOES NOT WORK\n\n    // The can opener by itself can open cans, but if we don't have a can\n    // then there's also no food.\n    val canOpener = new CanOpener(unsealer)\n\n    // We need both Can and CanOpener.\n    def openCan(can: Can, canOpener: CanOpener) = {\n      val food: Food = canOpener.open(can) // DOES WORK\n\n      println(s\"food = $food\")\n    }\n\n    openCan(canOfSpam, canOpener)\n  }\n}","title":"Amplification"},{"location":"/examples/abstraction.html","text":"","title":"Abstraction"},{"location":"/examples/abstraction.html#abstraction","text":"Packing lower level capabilities into more convenient APIs. See definition.\nThis is different from abstraction in that abstraction works to perform an operation using the lower level capabilities, but that operation could have been performed by working with the lower level capabilities individually i.e. no new functionality was revealed.\nHere’s an example of a repository exposed with several facets, with a higher level NameChanger capability composed out of two lower level ones.\n/**\n  * Demonstrates exposing capabilities as facets of a repository, so individual elements are exposed.\n  *\n  * The capabilities use tagless final to show how you can use different effects with capabilities.\n  *\n  * For example, the Id effect is an identity, so a failure will cause an exception.\n  *\n  * The Try effect is a disjoint union with Exception, so a failure will return Failure(Exception) as a result.\n  */\nobject RepositoryComposition {\n  val ID = UUID.fromString(\"c31d34e2-5892-4a2d-9fd5-3ce2e0efedf7\")\n\n  import ItemRepository._\n\n  val access = new ItemRepository.Access()\n\n  def main(args: Array[String]): Unit = {\n    val itemRepository = new ItemRepository()\n\n    changeWithId(itemRepository)\n    changeWithTry(itemRepository)\n  }\n\n  def changeWithId(itemRepository: ItemRepository): Unit = {\n    val idNameChanger = new NameChanger[Id](\n      access.finder(itemRepository),\n      access.updater(itemRepository),\n      _.map(identity)\n    )\n    val idResult = idNameChanger.changeName(ID, \"new name\")\n    println(s\"id result = $idResult\")\n  }\n\n  def changeWithTry(itemRepository: ItemRepository): Unit = {\n    val idFinder = access.finder(itemRepository)\n    val tryFinder = new Finder[Try] {\n      override def find(id: UUID): Try[Option[Item]] = Try(idFinder.find(id))\n    }\n\n    val idUpdater = access.updater(itemRepository)\n    val tryUpdater = new Updater[Try] {\n      override def update(item: Item): Try[UpdateResult] =\n        Try(idUpdater.update(item))\n    }\n\n    val tryNameChanger = new NameChanger[Try](tryFinder, tryUpdater, {\n      case Success(Some(result)) => result.map(Some(_))\n      case Success(None)         => Success(None)\n      case Failure(ex)           => Failure(ex)\n    })\n    val tryResult = tryNameChanger.changeName(ID, \"new name\")\n    println(s\"try result = $tryResult\")\n  }\n\n  class NameChanger[G[_]: Functor](\n    finder: Finder[G],\n    updater: Updater[G],\n    transform: G[Option[G[UpdateResult]]] => G[Option[UpdateResult]]\n  ) {\n    def changeName(id: UUID, newName: String): G[Option[UpdateResult]] = {\n      val saved: G[Option[G[UpdateResult]]] = finder.find(id).map {\n        maybeItem: Option[Item] =>\n          maybeItem.map { item =>\n            updater.update(item.copy(name = newName))\n          }\n      }\n      transform(saved)\n    }\n  }\n\n  case class Item(id: UUID, name: String)\n\n  class ItemRepository {\n    import ItemRepository._\n\n    private val items = Seq(Item(ID, \"item name\"))\n\n    private def find(id: UUID): Option[Item] = items.find(_.id == id)\n\n    private def update(u: Item): UpdateResult = UpdateResult(s\"item $u updated\")\n\n    private object capabilities {\n      val finder: Finder[Id] = new Finder[Id]() {\n        override def find(id: UUID): Id[Option[Item]] =\n          ItemRepository.this.find(id)\n      }\n      val updater: Updater[Id] = new Updater[Id]() {\n        override def update(item: Item): Id[UpdateResult] =\n          ItemRepository.this.update(item)\n      }\n    }\n  }\n\n  object ItemRepository {\n    trait Finder[F[_]] {\n      def find(id: UUID): F[Option[Item]]\n    }\n\n    trait Updater[F[_]] {\n      def update(item: Item): F[UpdateResult]\n    }\n\n    case class UpdateResult(message: String)\n\n    class Access {\n      def finder(repo: ItemRepository): Finder[Id] = repo.capabilities.finder\n      def updater(repo: ItemRepository): Updater[Id] = repo.capabilities.updater\n    }\n\n    class TryAccess(access: Access) {\n      def finder(repo: ItemRepository): Finder[Try] = new Finder[Try] {\n        override def find(id: UUID): Try[Option[Item]] = Try(access.finder(repo).find(id))\n      }\n      def updater(repo: ItemRepository): Updater[Try] = new Updater[Try] {\n        override def update(item: Item): Try[UpdateResult] = Try(access.updater(repo).update(item))\n      }\n    }\n  }\n\n}","title":"Abstraction"},{"location":"/examples/delegation.html","text":"","title":"Delegation"},{"location":"/examples/delegation.html#delegation","text":"import ocaps._\nimport scala.util._\n\nobject Delegation {\n  import Foo._\n\n  final class Foo(private var name: String) {\n    private def doTheThing() = {\n      println(s\"$name.doTheThing()\")\n    }\n\n    private object capabilities {\n      val doer: Doer = new Doer {\n        override def doTheThing(): Unit = Foo.this.doTheThing()\n      }\n    }\n  }\n\n  object Foo {\n\n    trait Doer {\n      def doTheThing(): Unit\n    }\n\n    class Access private {\n      def doer(foo: Foo): Doer = foo.capabilities.doer\n    }\n\n    object Access {\n      def apply(): Access = new Access\n    }\n  }\n\n  class User(name: String) {\n    def setDoer(doer: Doer) = {\n      maybeUser = Option(doer)\n    }\n\n    def delegateDoer(otherUser: User): Unit = {\n      maybeUser.foreach { myDoer =>\n        otherUser.setDoer(myDoer)\n      }\n    }\n\n    private var maybeUser: Option[Doer] = None\n\n    def doTheThing() = {\n      try {\n        maybeUser.foreach(_.doTheThing())\n      } catch {\n        case e: RevokedException =>\n          e.printStackTrace()\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val access = Foo.Access()\n\n    val foo = new Foo(\"foo\")\n    val doer = access.doer(foo)\n\n    val alice = new User(\"alice\")\n    alice.setDoer(doer)\n    val bob = new User(\"alice\")\n    alice.delegateDoer(bob)\n\n    println(s\"bob doing the thing through delegation:\")\n    val result = Try(bob.doTheThing())\n    println(s\"bob result: $result\")\n  }\n}","title":"Delegation"},{"location":"/examples/gatekeeper.html","text":"","title":"Gatekeeper"},{"location":"/examples/gatekeeper.html#gatekeeper","text":"This is an example of a gatekeeper in ocaps.\nA gatekeeper looks at the identity (aka security principal) and releases a set of capabilities in response. Note that the capability is not dependent on the security principal after authorization, i.e. there is no ambient authority.\nPlease see the authorization for more details on how authorization of capabilities is implemented.\nimport java.io.{BufferedReader, BufferedWriter, InputStream, OutputStream}\nimport java.nio.charset.StandardCharsets\nimport java.nio.file.{Files, _}\n\nimport ocaps._\nimport ocaps.macros._\n\nobject Gatekeeper {\n\n  import Document._\n\n  private val gatekeeper = new DocumentGatekeeper(Document.Access())\n\n  def main(args: Array[String]): Unit = {\n    val jeff = new User(\"jeff\")\n    val steve = new User(\"steve\")\n    val mutt = new User(\"mutt\")\n    val users: Seq[User] = Seq(jeff, steve, mutt)\n\n    // Admin can do anything, so it gets to create the documents...\n    val adminActivity = new AdminActivity(Access())\n    val documents = adminActivity.createDocuments(users)\n\n    for (user <- users) {\n      implicit val ctx: SecurityContext = new SecurityContext(user)\n      for (doc <- documents) {\n        val capabilities = gatekeeper.capabilities(doc)\n\n        // Capabilities are passed to the scope\n        // Everything inside this user activity scope is \"non-privileged\"\n        val userActivity = new UserActivity(user, capabilities)\n        userActivity.attemptDocument(doc)\n      }\n    }\n    adminActivity.deleteDocuments(documents)\n  }\n\n  /**\n   * Admin activities have direct access to all capabilities, as this is not a\n   * user context.\n   */\n  class AdminActivity(access: Access) {\n    def createDocuments(users: Seq[User]): Seq[Document] = {\n      for (owner <- users) yield {\n        val doc =\n          Document(owner = owner.name, Files.createTempFile(null, \".txt\"))\n        val writer = access.writer(doc)\n        writer.bufferedWriter(Seq(StandardOpenOption.SYNC)) { bw: java.io.BufferedWriter =>\n          bw.write(s\"Created by ${owner.name}\")\n        }\n        doc\n      }\n    }\n\n    def deleteDocuments(documents: Seq[Document]): Unit = {\n      documents.foreach { doc =>\n        val deleter = access.deleter(doc)\n        deleter.delete()\n      }\n    }\n  }\n\n  /**\n   * UserActivity operations are not guaranteed to have full access to capabilities.\n   */\n  class UserActivity(user: User, capabilities: Set[Capability]) {\n\n    def attemptDocument(doc: Document): Unit = {\n      maybeWriter(capabilities) match {\n        case Some(cap) =>\n          cap.bufferedWriter(Seq(StandardOpenOption.SYNC)) { nioWriter =>\n            nioWriter.write(s\"Written to by $user\")\n          }\n\n          println(s\"$user writing to $doc\")\n        case None =>\n          println(s\"$user CANNOT write to doc $doc\")\n      }\n\n      maybeReader(capabilities) match {\n        case Some(cap) =>\n          val result = cap.bufferedReader(buf => buf.readLine())\n          println(s\"$user reading from $doc: $result\")\n        case None =>\n          println(s\"$user CANNOT read from doc $doc\")\n      }\n    }\n  }\n\n  /** Simplest possible user */\n  class User(val name: String) {\n    override def toString: String = s\"User($name)\"\n  }\n\n  /**\n   * Gatekeeper controls who has access to capabilities.\n   */\n  class DocumentGatekeeper(access: Access) {\n\n    private val policy = new DocumentPolicy\n\n    private var userRevokerMap = Map[User, Revoker]()\n\n    def capabilities(doc: Document)(implicit ctx: SecurityContext): Set[Capability] = {\n      var capSets = Set[Document.Capability]()\n\n      var revokers = Set[Revoker]()\n      if (policy.canRead(ctx.user, doc)) {\n        val (reader, revoker) = revocable[Reader](access.reader(doc)).tuple\n        capSets += reader\n        revokers += revoker\n      }\n\n      if (policy.canWrite(ctx.user, doc)) {\n        val (writer, revoker) = revocable[Writer](access.writer(doc)).tuple\n        capSets += writer\n        revokers += revoker\n      }\n\n      if (policy.canDelete(ctx.user, doc)) {\n        val (deleter, revoker) = revocable[Deleter](access.deleter(doc)).tuple\n        capSets += deleter\n        revokers += revoker\n      }\n\n      userRevokerMap += (ctx.user -> Revoker.compose(revokers.toSeq: _*))\n\n      capSets\n    }\n\n    // If a user's session expires or the user misbehaves, we can revoke\n    // any access that the user has to all documents.\n    def revoke(user: User): Unit = {\n      userRevokerMap.get(user).foreach(_.revoke())\n    }\n\n    /**\n     * Define the operational contract between users and documents\n     *\n     * https://types.cs.washington.edu/ftfjp2013/preprints/a6-Drossopoulou.pdf\n     */\n    // Normal users can read anything, but only write to document they own.\n    class DocumentPolicy {\n      def canRead(user: User, doc: Document): Boolean = true\n\n      def canWrite(user: User, doc: Document): Boolean = {\n        isDocumentOwner(user, doc) || isAdmin(user)\n      }\n\n      def canDelete(user: User, doc: Document): Boolean = {\n        isDocumentOwner(user, doc) || isAdmin(user)\n      }\n\n      private def isDocumentOwner(user: User, doc: Document): Boolean = {\n        doc.owner.equals(user.name) || isAdmin(user)\n      }\n\n      private def isAdmin(user: User): Boolean = {\n        user.name.equals(\"admin\")\n      }\n    }\n\n  }\n\n  /**\n   * Implicit security context authorizes a particular user for a particular doc against a gatekeeper.\n   */\n  class SecurityContext(val user: User)\n\n  /**\n   * A document resource.  The path is private, and no operations are possible without\n   * an associated capability.\n   */\n  final class Document private(\n                                val owner: String,\n                                private[this] val path: Path\n                              ) {\n\n    private object capabilities {\n      val reader: Document.Reader = new Document.Reader {\n        override def bufferedReader[T](block: BufferedReader => T): T = {\n          val reader =\n            Files.newBufferedReader(Document.this.path, StandardCharsets.UTF_8)\n          try {\n            block(reader)\n          } finally {\n            reader.close()\n          }\n        }\n\n        override def inputStream[T](block: InputStream => T): T = {\n          val is = Files.newInputStream(Document.this.path)\n          try {\n            block(is)\n          } finally {\n            is.close()\n          }\n        }\n      }\n\n      val writer: Document.Writer = new Document.Writer {\n        override def bufferedWriter[T](\n                                        options: Seq[OpenOption] = Seq(StandardOpenOption.SYNC)\n                                      )(block: BufferedWriter => T): T = {\n          val bufWriter = Files.newBufferedWriter(\n            Document.this.path,\n            StandardCharsets.UTF_8,\n            options: _*\n          )\n          try {\n            block(bufWriter)\n          } finally {\n            bufWriter.close()\n          }\n        }\n\n        override def outputStream[T](\n                                      options: Seq[OpenOption]\n                                    )(block: OutputStream => T): T = {\n          val os = Files.newOutputStream(Document.this.path, options: _*)\n          try {\n            block(os)\n          } finally {\n            os.close()\n          }\n        }\n      }\n\n      val deleter: Document.Deleter = new Deleter {\n        override def delete(): Unit = Files.delete(Document.this.path)\n      }\n    }\n\n    override def toString: String = s\"Document(owner = $owner)\"\n  }\n\n  object Document {\n\n    trait Capability\n\n    trait Reader extends Capability {\n      def bufferedReader[T](block: BufferedReader => T): T\n\n      def inputStream[T](block: InputStream => T): T\n    }\n\n    trait Writer extends Capability {\n      def bufferedWriter[T](options: Seq[OpenOption])(block: BufferedWriter => T): T\n\n      def outputStream[T](options: Seq[OpenOption])(block: OutputStream => T): T\n    }\n\n    trait Deleter extends Capability {\n      def delete(): Unit\n    }\n\n    final class Access private {\n      def reader(document: Document): Reader = document.capabilities.reader\n\n      def writer(document: Document): Writer = document.capabilities.writer\n\n      def deleter(document: Document): Deleter = document.capabilities.deleter\n    }\n\n    object Access {\n      private val instance = new Access()\n\n      def apply(): Access = instance\n    }\n\n    def apply(owner: String, path: java.nio.file.Path): Document = {\n      new Document(owner, path)\n    }\n\n  }\n\n  private def maybeWriter(capabilities: Set[Capability]): Option[Writer] = {\n    capabilities.collectFirst {\n      case writer: Writer => writer\n    }\n  }\n\n  private def maybeReader(capabilities: Set[Capability]): Option[Reader] = {\n    capabilities.collectFirst {\n      case reader: Reader => reader\n    }\n  }\n\n}","title":"Gatekeeper"},{"location":"/examples/dynamic_seal.html","text":"","title":"Dynamic Sealing"},{"location":"/examples/dynamic_seal.html#dynamic-sealing","text":"import ocaps._\n\n// Brands allow for \"flexible private fields\" where\n// you have lexical scoping or in situations where\n// access modifiers are not suitable (i.e. there is not\n// a containing class)\nobject DynamicSeal {\n\n  trait Message\n\n  case object Save extends Message\n\n  case object Kill extends Message\n\n  trait Decision\n\n  case object Saved extends Decision\n\n  case object Killed extends Decision\n\n  // All of the users are of the same type, and so private fields\n  // are no good here.  In addition, the boxed field is public\n  // so anyone who is asking and who has the unsealer can see it.\n  case class User(\n    name: String,\n    sentencer: User => User = identity,\n    boxed: Option[Brand.Box[Message]] = None,\n    private val brand: Option[Brand[Message]] = None\n  ) {\n    def sentence(user: User): User = sentencer(user)\n\n    def process(user: User): Option[Message] = {\n      for {\n        box <- user.boxed\n        brand <- brand\n        message <- brand.unapply(box)\n      } yield message\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val softBrand = Brand.create[Message](\"Brand for Judge Softtouch\")\n    val doomBrand = Brand.create[Message](\"Brand for Judge Doom\")\n\n    val judgeSofttouch = User(\"Judge Softtouch\", sentencer = { user =>\n      user.copy(boxed = Some(softBrand(Save)))\n    }, brand = Some(softBrand))\n\n    val judgeDoom = User(\"Judge Doom\", sentencer = { user =>\n      user.copy(boxed = Some(doomBrand(Kill)))\n    }, brand = Some(doomBrand))\n\n    val steve = judgeDoom.sentence(User(\"steve\"))\n    val will = judgeSofttouch.sentence(User(\"will\"))\n    val judgedDoom = judgeSofttouch.sentence(judgeDoom)\n\n    val steveDecision = judgeDoom.process(steve)\n    println(\n      s\"User ${steve.name} has message ${steve.boxed} and decision $steveDecision\"\n    )\n    val willDecision = judgeSofttouch.process(will)\n    println(\n      s\"User ${will.name} has message ${will.boxed} and decision $willDecision\"\n    )\n\n    // What's going on here...\n    val judgeDecision = judgedDoom.process(judgedDoom)\n    println(\n      s\"User ${judgedDoom.name} has message ${judgedDoom.boxed} and decision $judgeDecision\"\n    )\n  }\n\n}","title":"Dynamic Sealing"},{"location":"/examples/membrane.html","text":"","title":"Membrane"},{"location":"/examples/membrane.html#membrane","text":"import java.time.ZonedDateTime\nimport java.time.format.{DateTimeFormatter, FormatStyle}\nimport java.util.{Locale, TimeZone}\n\nimport cats.Id\nimport ocaps._\n\n// http://blog.ezyang.com/2013/03/what-is-a-membran/\n\nobject Membrane {\n\n  import Location.{LocaleReader, TimeZoneReader}\n\n  class Location(locale: Locale, timeZone: TimeZone) {\n\n    private object capabilities {\n      val localeReader: Location.LocaleReader[Id] =\n        new Location.LocaleReader[Id] {\n          override val locale: Locale = Location.this.locale\n        }\n\n      val timeZoneReader: Location.TimeZoneReader[Id] =\n        new Location.TimeZoneReader[Id] {\n          override val timeZone: TimeZone = Location.this.timeZone\n        }\n    }\n\n  }\n\n  object Location {\n\n    trait LocaleReader[F[_]] {\n      def locale: F[Locale]\n    }\n\n    trait TimeZoneReader[F[_]] {\n      def timeZone: F[TimeZone]\n    }\n\n    class Access {\n      def localeReader(location: Location): LocaleReader[Id] = {\n        location.capabilities.localeReader\n      }\n\n      def timeZoneReader(location: Location): TimeZoneReader[Id] = {\n        location.capabilities.timeZoneReader\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n\n    class MembraneAccess(access: Location.Access, val membrane: PermeableMembrane) {\n      type Wrapper[+A] = membrane.Wrapper[A]\n\n      def localeReader(location: Location): LocaleReader[Wrapper] = {\n        new LocaleReader[Wrapper] {\n          override def locale: Wrapper[Locale] = {\n            membrane.wrap(access.localeReader(location).locale)\n          }\n        }\n      }\n\n      def timeZoneReader(location: Location): TimeZoneReader[Wrapper] = {\n        new TimeZoneReader[Wrapper] {\n          override def timeZone: Wrapper[TimeZone] = {\n            membrane.wrap(access.timeZoneReader(location).timeZone)\n          }\n        }\n      }\n    }\n\n    val m = RevokerMembrane()\n    val user = new Location(Locale.US, TimeZone.getTimeZone(\"PST\"))\n    val access = new MembraneAccess(new Location.Access(), m)\n\n    val dryLocale: LocaleReader[access.Wrapper] = access.localeReader(user)\n    val dryTimeZone: TimeZoneReader[access.Wrapper] =\n      access.timeZoneReader(user)\n\n    // Use an IO monad because the wrapper could throw revokerException when we call get\n\n    // Uncommment this to see the operation fail...\n    //m.revoke()\n\n    val format: access.Wrapper[String] = for {\n      timeZone <- dryTimeZone.timeZone\n      locale <- dryLocale.locale\n    } yield {\n      ZonedDateTime\n        .now(timeZone.toZoneId)\n        .format(\n          DateTimeFormatter\n            .ofLocalizedDateTime(FormatStyle.FULL)\n            .withLocale(locale)\n        )\n    }\n    println(format.get)\n  }\n\n}","title":"Membrane"},{"location":"/guide/index.html","text":"","title":"A Guide To Capabilities"},{"location":"/guide/index.html#a-guide-to-capabilities","text":"This is a guide to capabilities written for the general programmer, using Scala.\nNote If you are looking for examples of using ocaps, please see the examples sections.\nIntroducing Capabilities Constructing Capabilities Authorizing Capabilities Managing Capabilities Confining Capabilities","title":"A Guide To Capabilities"},{"location":"/guide/introduction.html","text":"","title":"Introducing Capabilities"},{"location":"/guide/introduction.html#introducing-capabilities","text":"Object oriented programming starts with a single object. Functional programming starts with a single function. The power in OOP and FP comes from being able to build and compose powerful structures out of these primitives. OOP is all about wiring objects together. FP is all about wiring functions together.\nIn the same way, Object-capability systems start with a single capability, and builds on it by wiring capabilities together. Just as an object is the primitive of OOP and a function is the primitive of FP, a capability is the primitive of OCAP.\nSo what is a capability?","title":"Introducing Capabilities"},{"location":"/guide/introduction.html#definition","text":"We use the following definitions for capabilities.\nA capability is a security primitive that confers authority by reference.\nWe use the following definition of authority:\nAn authority is sufficient justification to affect a resource.\nIn Scala, a resource is an object and a capability is a reference to an object that can affect that resource.\nNote that a capability may be a reference to the resource itself, or it may be a very indirect chain of forwarded calls to an inner class which can change the resource’s internals. As long as the end result is the same, it doesn’t matter.\nThere is an important difference between capabilities and object oriented programming. Whereas OOP is typically interested in making things accessible and creating graphs of things, a capability is a security tool, used for making things inaccessible. A capability is a precious thing, a tightly guarded key to a locked room full of treasure. You are only handed one, and if you lose it, then you must ask a gatekeeper to give you another one.","title":"Definition"},{"location":"/guide/introduction.html#scala-example","text":"Say that you have a class Foo:\ncase class Foo(name: String)\nA class by itself doesn’t mean anything – we have to create an instance of the class aka an object:\ndef createFoo: Unit = Foo(\"will\") // create the object!\nIn the above sample, we’ve left something out. We’ve created a Foo instance – but because the method returns Unit, there is no reference to the object. We can’t get the name. In order to be useful, we have to return a reference to the Foo instance:\ndef createFoo: Foo = Foo(\"will\")\nIf you have a reference to an object, you can, at a minimum, access all of the public methods and fields on that object.\nval foo = createFoo\n// now we can affect the object referred to as `foo` by accessing name\nval name = foo.name\nIf you call a method, or access a field, or modify a field, then you are affecting the resource. Therefore, your foo capability is sufficient justification to affect the resource that is the Foo instance.","title":"Scala Example"},{"location":"/guide/introduction.html#differences-between-capabilities-and-oo","text":"It may seem like the only thing we’ve done here is come up with different names for well known concepts, but that’s not actually the case. Capabilities come from a different space altogether, where “unforgeable references” meant long strings or signed and encrypted messages. Implementing capabilities in an OO language – object capabilities or ocap for short – is a very clean mapping, because references to objects can’t be forged or faked, and so much of the ground level work has already been done.\nBut what distinguishes a capability from a plain old object reference? There are a few qualifications:\nThe resource is valuable, and typically long lived. It contains methods and data that should not be touched lightly. Controlling access to the resource is important. The capability is the only way to access the resource. There is no back door (DI framework, static holder) reference that “gets around” the capability model. The capability is opaque. You have an object reference to a trait, but you can’t downcast that, introspect it, change access modifiers etc. The trait may run through any number of forwarders (the ‘capability’ word for filters / proxies / delegates) before executing the call on the resource, and there is no way to circumvent that.","title":"Differences between Capabilities and OO"},{"location":"/guide/introduction.html#caveats-and-assumptions","text":"The assumption in this document is that you are playing a straight game, where references are handled only through creation (you created the reference), parentage (you are a subclass and you have access to references scoped by your parent class), or through scoping (you were handed references through parameters in the class, or followed an existing reference).\nBasically, you’re not setting or accessing capabilities through global state through singleton objects, static fields, or thread locals. You can use Akka and only send capabilities through messages between actors for a more accurate capability model, but it’s not required.\nLikewise, we assume that you’re not a hostile attacker – if you are hostile and can execute code in the JVM, it’s trivial to subvert the SecurityManager, call setAccessible and start monkeypatching, so effectively all fields and methods are public if you scratch hard enough. Scala is not an ocap language, so this is purely about capabilities as a software engineering practice.","title":"Caveats and Assumptions"},{"location":"/guide/construction.html","text":"","title":"Constructing Capabilities"},{"location":"/guide/construction.html#constructing-capabilities","text":"The introduction gave a basic explanation of capabilities, but did not demonstrate why access to the capability is so important.\nIn esssence, a capability is a programming level expression of the saying “You can only eat your cake if you have it.”\ntrait Cake {\n  def eat(): Unit\n}\nval cake = new Cake() {\n  def eat() = ()\n}\ncake.eat()\nYou may know that a resource (an instance of Cake) exists, but you still need an object reference cake in order to affect the Cake instance by calling the eat() method on it. This is a fairly trivial example, because if you can instantiate a cake yourself, you will have no problem referencing it.\nThings start getting more interesting when you add more objects, and you don’t control or instantiate resources directly. For example, you may not be able to make cakes yourself, so you go to a bakery.\ntrait Bakery {\n  def buy(): Cake \n}\n\nclass Person(val bakery: Bakery) {\n  def buyAndEatCake() = eatCake(bakery.buy())\n  def eatCake(cake: Cake) = cake.eat()    \n}\nval bakery = new Bakery() {\n  def buy(): Cake = new Cake() { \n    def eat() = ()\n  }\n}\nval you = new Person(bakery)\nyou.buyAndEatCake()\nHere, you’re still interested in affecting a resource Cake by, well, eating it, but you don’t have direct access to the cake. Instead, you, an instance of a Person, have a reference to a Bakery, and that Bakery may give you a cake.\nNote that because bakery is an object reference, it is also a capability. You can’t buy things from a bakery unless you know how to get to one.\nThe bakery may give you a cake. But it may throw an exception, because they don’t have cakes or you don’t have enough money, or because they’re closed. In addition, you don’t control the behavior of the eat method. You have a reference, but that reference is a contract and it’s the object that chooses how to execute it – when you call cake.eat(), that may also throw an exception or do something behind the scenes.\nAnd this is where the power of capabilities comes in. As it stands, you can eat a cake as often as you like. The bakery may want you to only eat a cake once. Because the bakery controls access to the resource, it can enforce a capability policy around the eating of cake.\nval enforcingBakery = new Bakery() {\n  def buy(): Cake = {\n    val latch = new java.util.concurrent.atomic.AtomicInteger(1)\n    val realCake = new Cake() {\n      def eat() = ()\n    }\n    new Cake() {\n      def eat() = {\n        if (latch.getAndDecrement == 1) {\n          realCake.eat()\n        } else {\n          throw new RuntimeException(\"You have already eaten this cake!\")\n        }\n      }\n    }\n  }\n}\n\nval sneakyYou = new Person(enforcingBakery)\nval oneTimeCake = sneakyYou.bakery.buy()\nsneakyYou.eatCake(oneTimeCake)\nsneakyYou.eatCake(oneTimeCake)\nYou may get an object reference – a capability – to a Cake. But here, the actual cake is only accessible through a delegate (also called a “forwarder”) which proxies the call. You have no direct access to the resource (realCake), and you can affect the resource (call realCake.eat()) only if the proxy allows it. The proxy may refuse to proxy the call. This is called revocation, and it is a key part of capability-based systems.\nSo if the only way you can get a cake is through a bakery, then you have to play by the bakery’s rules.","title":"Constructing Capabilities"},{"location":"/guide/construction.html#creating-capabilities-through-facets","text":"Let’s dig a little deeper and discuss capabilities in the context of a CRUD based repository, and show how resources and capabilities interact, and how to expose capabilities.\nIt’s worth noticing that because a capability is an object reference, a resource which has an exposed capability is always referencable and so will not be eligible for garbage collection. In certain cases, we have many capabilities to resources which are no longer valid, such as cached items, or may have open filehandles. You should use or ocaps.WeakResource to wrap access to a resource in a weak reference.\nWhen you think of a repository, you usually think of something like the following:\nimport scala.concurrent._\ncase class Item(id: UUID, name: String)\ntrait ItemRepository {\n  def create(item: Item): Future[Item]\n  def update(item: Item): Future[Item]\n  def delete(id: UUID): Future[Unit]\n  def find(id: UUID): Future[Option[Item]]\n}\nHowever, recall the first rule: if you have a cake, you can eat it. If you have access to an ItemRepository, you can call all of the methods available on ItemRepository. If a class just wants to query for an item, it doesn’t need the ability to create, update or delete that item.\ncase class Item(id: UUID, name: String)\nobject ItemRepository {\n  trait Finder {\n    def find(id: UUID): Future[Option[Item]]\n  }\n  trait Updater {\n    def update(item: Item): Future[Item]\n  }\n  trait Deleter {\n    def delete(id: UUID): Future[Unit]\n  }\n  trait Creator {\n    def create(item: Item): Future[Item]\n  }\n}\ntrait ItemRepository \n  extends ItemRepository.Finder \n  with ItemRepository.Updater\n  with ItemRepository.Creator\n  with ItemRepository.Deleter\nHere, we’ve broken down the individual methods of the ItemRepository into a series of traits. Rather than exposing the ItemRepository itself, we can expose the traits individually, and build up the repository as a composition of capabilities.\nval item = Item(UUID.randomUUID(), \"item\")\nval repo = new ItemRepository() {\n  def create(item: Item): Future[Item] = Future.successful(item)\n  def update(item: Item): Future[Item] = Future.successful(item)\n  def delete(id: UUID): Future[Unit] = Future.successful(())\n  def find(id: UUID): Future[Option[Item]] = Future.successful(item)\n}\n\nval finder = new ItemRepository.Finder() {\n  def find(id: UUID): Future[Option[Item]] = repo.finder(id)\n}\nWhen we have a pattern like this, where capabilities have a shared underlying resource, we say that they are facets of the resource. In this case, we have a finder facet of the ItemRepository resource. Note that we create a new Finder instance, and proxy through to repo.finder. This is called attenuation. Facets do not have to be created through attenuation, and in some cases it’s undesirable because it fixes traits onto the resource. We’ll show another way facets can be created later in this section.\nNow we have the facet, we can use it in other operations:\nclass NameChanger(finder: ItemRepository.Finder) {\n  def findName(id: String): Future[String] = finder.find(id).map { maybeItem =>\n    maybeItem.map(_.name)\n  }\n}\nYou would think that since ItemRepository implements the Finder trait itself, that you could just pass it around directly. The problem there is that an object reference is still an object reference no matter what type you give it. As such, you can get access to the other facets by downcasting to ItemRepository:\nval onlyAFinder: ItemRepository.Finder = repo\nval recoveredRepo: ItemRepository = onlyAFinder.asInstanceOf[ItemRepository]","title":"Creating Capabilities Through Facets"},{"location":"/guide/construction.html#effects-in-capabilities-with-tagless-final","text":"Rather than throwing exceptions as a side effect, capabilities can make use of functional programming techniques. For example, rather than commit to a monix.Task[_] or a Try[_], a capability may be expressed in tagless final style with a type parameter F that is a standin for the thing you want:\nobject ItemRepository {\n  trait Finder[F[_]] {\n    def find(id: UUID): F[Option[Item]]\n  }\n}\nWe refer to this as an effect, where effect means “whatever distinguishes F[A] from A.”\nThe capabilities companion is defined using cat.Id, which essentially means “no effect here”:\nimport cats._\nclass ItemRepository {\n  import ItemRepository._\n  private val items = Seq(Item(UUID.randomUUID(), \"item name\"))\n  private object capabilities {\n    val finder: Finder[Id] = new Finder[Id]() {\n      override def find(id: UUID): Id[Option[Item]] = items.find(_.id == id)\n    }\n  }\n}\nAnd then the effect – in this case Try – can be wrapped around the original capability instance.\nval idFinder = access.finder(itemRepository)\nval tryFinder: Finder[Try] = new Finder[Try] {\n  override def find(id: UUID): Try[Option[Item]] = Try(idFinder.find(id))\n}\nWhen using Try, the find method will return either Success(maybeItem) or Failure(throwable) as a result, rather than throwing an exception up the stack.","title":"Effects in Capabilities with Tagless Final"},{"location":"/guide/construction.html#creating-capabilities-through-access-modifiers","text":"Creating a resource which exposes all its public methods is very convenient in situations where direct access to the resource is tightly restricted, and all external access is regulated through facets. This is not always the case: for example, in an Inversion-of-Control container like Spring or Guice, all resources are accessible, i.e.\nval repoThroughGuice = injector.instanceOf(classOf[ItemRepository])\nrepoThroughGuice.delete(\"1\") // anyone can delete\nIn this situation, it may be desirable in some cases to have a resource with public methods, and a “protected” set of capabilities that are not accessible:\ntrait ItemRepository {\n  def name: String  // okay for anyone to access this!\n  \n  private[???] def deleter: Deleter // only accessible to authorized objects, if we knew what ??? was\n}\nThere is a way to implement this! In Scala, only the public methods on an object are exposed – private methods cannot be referenced externally. We can use Scala’s access modifiers and qualifiers to selectively expose capabilities. We’ll demonstrate in this section.\nSo, say you have a class Document, with a private Path that contains the text of the document.\nimport java.nio.file._\nfinal class Document(private[this] val path: Path) {\n    ...\n}\nWe want to restrict access so that we can read from the document without exposing the path.\nFirst, we create a companion object Document and add a NameChanger trait:\nobject Document {\n  trait Reader {\n    def bufferedReader[T](block: BufferedReader => T): T\n  }\n}\nNext, we create a private singleton object called capabilities and add a reader implementation:\nfinal class Document(private[this] val path: Path) {\n  private object capabilities {\n    val reader: Document.Reader = new Document.Reader {\n      override def bufferedReader[T](block: BufferedReader => T): T = {\n        val reader = Files.newBufferedReader(Document.this.path, StandardCharsets.UTF_8)\n        try {\n          block(reader)\n        } finally {\n          reader.close()\n        }\n      }\n    }\n  }\n}\nFinally, we add an Access class that can expose the Reader for a particular Document instance:\nobject Document {\n  final class Access private {\n    def reader(doc: Document): Reader = doc.capabilities.reader\n  }\n  object Access {\n    private val instance = new Access()\n    def apply(): Access = instance\n  }\n}\nIn order to have a reference to a reader, you must have access to both a Document.Access instance and a Document:\nval path = Path.get(\"document.txt\")\nval document = new Document(path)\nval access = Document.Access()\nval reader = access.reader(document)\nval text = reader.bufferedReader(_.readLine())\nWhen you put two capabilities together to expose functionality that is more than the individual pieces, it is called amplification. Other useful examples of amplification are when a “can” and a “can opener” are put together, or a “private key” and “document encrypted with public key.”\nCreating an Access class can also be useful because it can mediate between a resource and the capabilities on the resource, without directly involving the resource itself. For example, referring back to the effects section above, a TryAccess class may provide a Try effect on all the capabilities of the Document.\nfinal class TryAccess private {\n  def reader(doc: Document): Reader[Try] = Try(doc.capabilities.reader)\n}\nOr you can go for a full-on type class approach:\nobject Document {\n  trait NameChanger[F[_]] {\n    def changeName(name: String): F[Unit]\n  }\n\n  trait WithEffect[C[_[_]], F[_]] {\n    def apply(capability: C[Id]): C[F]\n  }\n\n  // The default \"no effect\" type Id[A] = A\n  implicit val idEffect: NameChanger WithEffect Id = new WithEffect[NameChanger, Id] {\n    override def apply(capability: NameChanger[Id]): NameChanger[Id] = identity(capability)\n  }\n\n  // Apply a \"Try\" effect to the capability\n  implicit val tryEffect: NameChanger WithEffect Try = new WithEffect[NameChanger, Try] {\n    override def apply(capability: NameChanger[Id]): NameChanger[Try] = new NameChanger[Try] {\n      override def changeName(name: String): Try[Unit] =  Try(capability.changeName(name))\n    }\n  }\n\n  class Access {\n    def nameChanger[F[_]](doc: Document)(implicit ev: NameChanger WithEffect F): NameChanger[F] = {\n      val effect = implicitly[NameChanger WithEffect F]\n      effect(doc.capabilities.nameChanger)\n    }\n  }\n}\n\nval idNameChanger = access.nameChanger[Id](document)\nThis does of course leave the question open of how you manage access to the Access instance, since it hands out capabilities to anyone who asks. This leads into the next section.","title":"Creating Capabilities Through Access Modifiers"},{"location":"/guide/authorization.html","text":"","title":"Authorizing Capabilities"},{"location":"/guide/authorization.html#authorizing-capabilities","text":"","title":"Authorizing Capabilities"},{"location":"/guide/authorization.html#authorization-and-ambient-authority","text":"One of the issues that the capability model neatly sidesteps is the issue of ambient authority.\nBroadly speaking, ambient authority is when a user or a security context (also known as a “Principal”) is assumed to exist when making sensitive calls, and the credentials of the “current user” are applied every time.\nIn Java, ambient authority would typically come in the form of a thread-local user context that would be accessible from every method. In Scala, it typically takes the form of an implicit User or SecurityContext that is always accessible.\nIn a capability model, authorization is used only and solely to dispense the capability. After that point, the capability is passed around without an implicit SecurityContext and without ambient authority. If the user logs out at any point, then the capability is revoked.","title":"Authorization and Ambient Authority"},{"location":"/guide/authorization.html#authorizating-capabilities-with-gatekeeper","text":"Handing out a capability to an object gives the object authority over the resource. The question of whether that object should have authority or not is an authorization decision. The question of authorization (“what authority”) is usually accompanied by the question of authentication (“who should have this authority?”).\nIn capability based systems, there are four stages before a capability is handed out. Alan Karp defines four stages:\nIdentification (grant privs) Authentication (let a process running on behalf use priv associated with identity) Authorization (grant token, etc) Access Decision (in the service)\nCapability-based authorization systems identify a policy that says who is authorized for an operation on a resource, and then hand out a capability for that operation. That capability is then used directly. This is in contrast to role based access control (RBAC), which ties in the identity directly. Examples include OAuth 2 Bearer Token and XACML, but it’s quite simple to create your own.\nThis may not mean much in isolation, so let’s run through an example with Scala code, implementing a Gatekeeper class for documents.\nYou can see the full class in Gatekeeper example page.\nFirst, we need authentication. Let’s posit a User class that serves as the principal, and an implicit SecurityContext that serves as an implicit context.\ncase class User(name: String)\nclass SecurityContext(val user: User)\nWe also need to extend Document slightly to have an owner field:\nfinal class Document private(val owner: String,\n                             private[this] val path: Path) {\n   ...\n}\nNext, we put together a DocumentGatekeeper. This takes a reader(doc: Document) with the SecurityContext as an implicit parameter, and returns the Document.Reader capability only if it passes the document policy.\nclass DocumentGatekeeper() {\n\n  private class DocumentPolicy {\n    def canRead(user: User, doc: Document): Boolean = {\n      isDocumentOwner(user, doc) || isAdmin(user)\n    }\n    private def isDocumentOwner(user: User, doc: Document): Boolean = {\n      doc.owner.equals(user.name) || isAdmin(user)\n    }\n    private def isAdmin(user: User): Boolean = {\n      user.name.equals(\"admin\")\n    }\n  }\n\n  private val access = Document.Access()\n  private val policy = new DocumentPolicy\n  \n  def reader(doc: Document)(implicit ctx: SecurityContext): Try[Reader] = {\n    if (policy.canRead(ctx.user, doc)) {\n      Success(access.reader(doc))\n    } else {\n      Failure(new CapabilityException(s\"Cannot authorize ${ctx.user} for writer to doc $doc\"))\n    }\n  }\n}\nA gatekeeper is not complicated, but it’s important to note it should be involved only when granting capabilities.\n// Assume authentication happens up here...\nval user = new User(\"will\")\nimplicit val sc = new SecurityContext(will)\n\n// Access the document...\nval doc = new Document(user.name, path)\n\n// get reader or throw exception\nval reader = gatekeeper.reader(doc).get\n\n// pass around reader to actor here...\nsystem.actorOf(DocumentActivityActor.props(reader))\n\n// Or create new Activity class instance with reader as constructor parameter\nval userActivity = new DocumentActivity(reader)\nFrom the time the capability is accessible, it is “in scope” of the application code, and may be not tied to the lifecycle of the user session. That is, there may be a job or a process which can run with the reader well after the user has logged out. The SecurityContext is only required by the gatekeeper, and is not required by any following activity. There is no ambient authority.\nThe discussion around capabilities and their lifecycles, and how capabilities can be passed around and delegated to other classes is the biggest point of difference between permission based access control (which always requires an identity context) and capability based access control (which depends on an object reference). In short, once you have assigned capabilities, you must then manage them.","title":"Authorizating Capabilities with Gatekeeper"},{"location":"/guide/authorization.html#dispensing-capabilities-with-composition","text":"When there are several capabilities that may be available from authorization, one common pattern is to return a set of capabilities to the caller, providing a range of options.\nclass Caller(capabilities: Set[Capability]) {\n ...\n}\n\nval capabilitySet = Set(reader, writer)\nval caller = new Caller(capabilitySet)\nNote that Caller does not know what capabilities may be presented to it, and so must iterate to see if it has access. This is fine as far as it goes, but it does inherently provide collection mechanics on top of managing capabilities, and loses some type information.\nAnother option is to use composition to return an object that directly incorporates all the capabilities.\nclass Caller(caps: Reader with Writer) {\n ...\n}\n\nval capabilities = ocap.macros.compose[Reader with Writer](reader, writer)\nval caller = new Caller(capabilities)\nNow the caller can pattern match directly against the capability:\nclass Caller(capabilities: AnyRef) {\n  private def reader: Option[Reader] = {\n    capabilities match {\n      case reader: Reader =>\n        Some(reader)\n      case _ =>\n        None\n    }\n  }\n}\nOr, if the caller has specific type information that is needed from a composed capability, the provider can extract the facets through attenuation:\nclass Caller(reader: Reader, writer: Writer) {\n  ...\n}\n\nval reader: Reader = ocaps.macros.attenuate[Reader](capabilities)\nval writer: Writer = ocaps.macros.attenuate[Writer](capabilities)\n\nval caller = new Caller(reader, writer)\nYou can see a complete attenuation example for more details. Also see the gatekeeper example.\nComposition is not the only way of arranging capabilities, of course. Joe Duffy has a great post where he discusses the practical aspects of capabilities:\nI’ll be the first to admit, there was a maturity process that developers went through, as they learned about the design patterns in an object capability system. It was common for “big bags” of capabilities to grow over time, and/or for capabilities to be requested at an inopportune time. For example, imagine a Stopwatch API. It probably needs the Clock. Do you pass the Clock to every operation that needs to access the current time, like Start and Stop? Or do you construct the Stopwatch with a Clock instance up-front, thereby encapsulating the Stopwatch’s use of the time, making it easier to pass to others (recognizing, importantly, that this essentially grants the capability to read the time to the recipient). Another example, if your abstraction requires 15 distinct capabilities to get its job done, does its constructor take a flat list of 15 objects? What an unwieldy, annoying constructor! Instead, a better approach is to logically group these capabilities into separate objects, and maybe even use contextual storage like parents and children to make fetching them easier.\nAs in all things, choose the solution that works best for your context.","title":"Dispensing Capabilities with Composition"},{"location":"/guide/management.html","text":"","title":"Managing Capabilities"},{"location":"/guide/management.html#managing-capabilities","text":"Management of capabilities is based around the concepts of revocation and modulation: being able to stop a capability that has already been assigned, and being able to augment the behavior of capabilities for security purposes.","title":"Managing Capabilities"},{"location":"/guide/management.html#managing-accessibility-with-revocation","text":"This naturally brings up the question of how to limit access to an already granted capability, for example to limit the lifespan of a capability to the lifespan of a user session, so the capability is no longer valid after logout or timeout. This is done using revocation, but more importantly, this is done using a whole series of constructs based around revocation, the most important being the Revocable pattern, also known as the Caretaker.\nNote Please see the Revocation example for a complete example.\nWe’ve shown an example of revocation in the bakery above, but revocation as a concept is important enough that it has a specific trait associated with it – a Revoker:\npackage ocaps\n\ntrait Revoker {\n  def revoke(): Unit\n}\nA revoker does one thing – it revokes access to a proxied capability. When the revoke method is invoked, the proxy will no longer forward calls to the capability, and will instead throw a RevokedException.\nOf course, a Revoker does no good without something to revoke.\nThe Revocable handles the creation of a revoker and associated proxy. The apply method of the Revocable is implemented as follows:\npackage ocaps\n\nobject Revocable {\n  def apply[C](capability: C)(cblock: (() => C) => C): Revocable[C] = {\n    val (thunk, revoker) = Revoker.tuple(capability)\n    val revocableCapability: C = cblock(thunk)\n    Revocable(revocableCapability, revoker)\n  }\n}\nThe cblock of the Revocable is a constructor block – it passes in a capability thunk, and returns the proxy implementation.\nimport ocaps._\n\ntrait Doer {\n  def doTheThing(): Unit\n}\n\nobject Doer {\n  def revocable(doer: Doer): Revocable[Doer] = {\n    Revocable(doer) { thunkedDoer =>\n      new Doer {\n        override def doTheThing(): Unit = thunkedDoer().doTheThing()\n      }\n    }\n  }\n}\nand will be used as follows:\nval Revocable(revocableDoer, revoker) = Doer.revocable(access.doer)\nrevocableDoer.doTheThing() // works fine\nrevoker.revoke()\nrevocableDoer.doTheThing() // throws exception!\nYou can also use the revocable macro, which will create the implementation proxy automatically:\nimport ocaps._\nimport ocaps.macros._\n\n// takes a `Doer` trait as a type parameter and autocreates implementation\nval Revocable(revocableDoer, revoker) = revocable[Doer](access.doer)\nIf you have several revokers, you can compose them together using `Revoker.compose``:\nval revokerABC = Revoker.compose(revokerA, revokerB, revokerC)\nrevokerABC.revoke() // revoke A, B, and C all at the same time.\nBy using revokers, you can tie capabilities to the lifespan of a user session by revoking them on session close or timeout. Any call to the capability after revocation will result in failure. For this reason, revocation is sometimes called temporal attenuation.\nRecovery from revocation is application specific. If an operation fails, the component that owns the capability may request a fresh new capability to replace the revoked one, or may require reauthorization or reauthentication before reinstantiation. Akka Actors work extremely well in this context, as does judicious use of the IO monad.","title":"Managing Accessibility with Revocation"},{"location":"/guide/management.html#managing-behavior-with-modulation","text":"Modulation is an extremely powerful technique that wraps a capability in additional behavior. The canonical example of modulation is logging:\ndef loggingDoer(doer: Foo.Doer, logger: Logger): Foo.Doer = {\n  new Foo.Doer {\n    override def doTheThing(): Int = {\n      logger.info(s\"doTheThing: before call\")\n      val result = doer.doTheThing()\n      logger.info(s\"doTheThing: after returns $result\")\n      result\n    }\n  }\n}\nNote Please see modulation for a complete example.\nModulation of a capability must obey behavioral subtyping – it is acceptable to throw an exception and fail in security related conditions, but it is not acceptable to add new functionality, because it violates the Liskov substitution principle. For example, the following is extremely rude:\ndef badlyBehavedDoer(doer: Foo.Doer, logger: Logger): Foo.Doer = {\n  new Foo.Doer {\n    override def doTheThing(): Int = {\n      val result = doer.doTheThing()\n      if (result > 0) -1 else result // NEVER DO THIS\n    }\n  }\n}\nModulation can be used in a design by contract style preconditions and postconditions. For example, given an ItemRepository.Finder, we can specify a finder which must match a particular id (often called narrowing):\ndef idPreFinder(finder: ItemRepository.Finder, validIds: Set[UUID]): ItemRepository.Finder = {\n  new ItemRepository.Finder {\n    def find(id: UUID): Option[Item] = {\n      if (validIds.contains(id)) {\n        finder.find(id)\n      } else {\n        throw new CapabilityException(\"Invalid id!\")\n      }\n    }\n  }\n}\nOr modulation can verify a post condition exists – for example, ensuring that only items owned by a particular user can be found:\ndef userPostFinder(finder: ItemRepository.Finder, user: User): ItemRepository.Finder = {\n  new ItemRepository.Finder {\n    def find(id: UUID): Option[Item] = {\n      val result = finder.find(id)\n      result.foreach { item =>\n         if (! item.owner.equals(user)) {\n           throw new CapabilityException(\"Invalid id!\")\n         }\n      }\n      result\n    }\n  }\n}\nUsing modulation with capabilities, additional security guarantees can be added transparently to operations.\nTo skip the boilerplate, there is a capability macro which can automate the implementation of modulation by providing before and after functions:\nimport ocaps.macros._\n\ndef loggingDoer(doer: Foo.Doer, logger: Logger): Foo.Doer = {\n  val before: String => Unit = methodName => {\n    logger.info(s\"$methodName: before call\")\n  }\n  val after: (String, Any) => Unit = (methodName, result) =>\n    logger.info(s\"$methodName: after returns $result\")\n  modulate[Foo.Doer](doer, before, after)\n}","title":"Managing Behavior with Modulation"},{"location":"/guide/management.html#managing-lifecycle-with-expiration","text":"Expiration combines modulation of a capability with revocation. Using modulation, a capability can make use of internal or external state to decide whether it should revoke access through an internal revoker.\nNote Please see Expiration example for a complete example.\nExpiration can be used to create a limited use capability, which is revoked after a certain number of calls.\ndef countBasedExpiration(doer: Foo.Doer, count: Int): Foo.Doer = {\n  val latch = new java.util.concurrent.atomic.AtomicInteger(1)\n  val Revocable(revocableDoer, revoker) = revocable[Foo.Doer](doer)\n  val before: (String, Any) => Unit = (_, _) =>\n   if (latch.getAndDecrement() == 0) {\n     revoker.revoke()\n   }\n  modulate[Foo.Doer](revocableDoer, before, after)\n}\nCount based expiration is especially useful when delegating a capability to an external worker which may execute at a much later date. If you recall the bakery that allows you to eat your cake once and only once, this is a generalization of the technique.\nA capability can also limit access by only allowing access based on a timer:\ndef timerBasedExpiration(doer: Foo.Doer, duration: FiniteDuration): Foo.Doer = {\n  val deadline = duration.fromNow\n  val Caretaker(revokerDoer, revoker) = caretaker[Foo.Doer](doer)\n  val before: String => Unit = _ => if (deadline.isOverdue()) {\n                                      revoker.revoke()\n                                    }\n  val after: (String, Any) => Unit = (_, _) => ()\n  }\n  modulate[Foo.Doer](revokerDoer, before, after)\n}\nTimer based expiration is helpful in resisting Time of Check/Time of Use attacks and providing “sudo” mode for limited admin access.\nExpiration can also depend on external behavior, such as a supervisor that may look for suspicious activity.\ndef supervisorBasedExpiration(doer: Foo.Doer, supervisor: Supervisor): Foo.Doer = {\n  val Revocable(revokerDoer, revoker) = revocable[Foo.Doer](doer)\n  val before: String => Unit = _methodName => {\n    if (! supervisor.accept(doer, methodName)) {\n      revoker.revoke()\n    }\n  }\n  val after: (String, Any) => Unit = (_, _) => ()\n  modulate[Foo.Doer](revokerDoer, before, after)\n}","title":"Managing Lifecycle with Expiration"},{"location":"/guide/confinement.html","text":"","title":"Confining Capabilities"},{"location":"/guide/confinement.html#confining-capabilities","text":"Managing capabilities in the context of an architecture can be complex.\nOne issue is that managing capabilities can mean limiting scope and access to an object reference, but many architectures assume a context in which all object references are publically accessible – for example, events may be sent across an event bus, or through a streaming model. And because data structures inherently involve object references, there’s the question of how to keep capabilities safe and isolated.\nWe touched on this a little bit in the Access class which uses access modifiers and a companion object to construct capabilities which cannot be accessed directly. Unfortunately, in Scala, access modifiers and qualifiers only apply to enclosing scope, so there is no way to qualify private access to things outside that scope. However, there is a way to protect capabilities to produce this effect – through the use of Brand.","title":"Confining Capabilities"},{"location":"/guide/confinement.html#encapsulating-capabilities-with-brands","text":"A Brand is a means of “providing data abstraction in the absence of static typing.” It consists of a sealing function, which provides a “boxed” reference to the capability which cannot be opened, and an unsealing function, which takes the box, and returns the contained capability. The best way of describing it is that a Brand provides both a canner and the associated can opener.\nimport ocaps.Brand\n\nobject Main {\n  case class Food(name: String)\n  case class Can(food: Brand.Box[Food])\n  class CanOpener(unsealer: Brand.Unsealer[Food]) {\n    def open(can: Can): Food = {\n      unsealer(can.food).get // throws exception if we did not seal this\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val (sealer, unsealer) = Brand.create[Food](\"canned food\").tuple\n    val canOfSpam: Can = Can(sealer(Food(\"spam\")))\n\n    val cannedFood: Brand.Box[Food] = canOfSpam.food\n    println(s\"food = ${canOfSpam.food.toString}\") // DOES NOT WORK\n    val canOpener = new CanOpener(unsealer)\n\n    // We need both Can and CanOpener to unseal.\n    def openCan(can: Can, canOpener: CanOpener) = {\n      val food: Food = canOpener.open(can)\n      println(s\"food = $food\") // WORKS\n    }\n\n    openCan(canOfSpam, canOpener)\n  }\n}\nBecause both an unsealer and the sealed item are necessary to unseal, the act of unsealing is inherently a case of amplification, where putting two capabilities together lets you do things that neither one could do individually.\nSealers can be used for many things. It’s helpful to think of them in the context where you would use public key encryption, for example\nSigning – an box can be passed around and an unsealer on a resource can be made public, attesting to its origin. Encryption – a public sealer can “encrypt” information by boxing it, and sending it to an actor with the sealer. Assurance – boxed information can be passed out and round tripped to the original source, ensuring that the information has not been modified in transit. Private Channel – two actors can pass information to each other using sealed boxes, ensuring that sensitive information is not exposed even if the message is intercepted or LoggingReceive is enabled.\nOne possible application of dynamic sealing is that all Access objects can be sealed and safely bound in a dependency injection framework, and a revocable unsealer capability can be passed around to enable access from a central gatekeeper. I still need to implement this, but I think it’s fairly straightforward.\n// import scalaguice so we don't use new TypeLiteral[Box[Foo.Access]] {}\nclass Module extends ScalaModule {\n  def configure() = {\n    bind[Box[Foo.Access]]\n     .toProvider(fooAccessProvider)\n     .in(Scopes.SINGLETON)\n  }\n}\nThis can also be used to pass around “root level” objects such as database connections and JSSE key managers that you may want to restrict access to generally. Anyone using the database connection will have to unseal it, and you can provide the unsealer capability to use revocation or logging to flush it out.\nPlease see the Dynamic Sealing example for a demonstration.\nDynamic sealing has an independent lineage from capabilities programming. The original paper, Protection in Programming Languages was written in 1973, However, the morning paper summary on the paper is actually clearer and better written than the paper itself.\nRobust and Compositional Verification of Object Capability Patterns has a section on dynamic sealing.\nThe discussion on the use of dynamic sealing in communication channels is from Modules, Abstract Types, and Distributed Versioning.","title":"Encapsulating Capabilities with Brands"},{"location":"/guide/confinement.html#confining-operations-with-membranes","text":"A membrane is an extension of a Revocable that transitively imposes revocability on all references exchanged via the membrane.\nMembranes are supposed to stop messages passing from one place to another without being wrapped. They are most commonly used for “uncooperative revocation”, although any effect can be applied with a membrane, not just revocation.\nMembranes are useful in a situation in which you have to run some foreign code in a sandbox, and you absolutely do not trust it. Tellingly, the papers above implement membranes using Javascript, where any website can tell code to be run locally in the browser. Mozilla uses capabilities heavily internally, and membranes ensure an airgap between the browser’s internal code and the code available to the site Javascript.\nThe JVM is not a great platform for implementing a completely safe membranae. In particular, the JVM SecurityManager is easily subverted, and Java Serialization attacks mean that the boundary is very hard to enforce.\nIn general, the best way to implement a membrane in Java would be to implement a generic method interceptor in Byte Buddy and attach behavior outside of the context of “normal” Java code.\nHowever, because membranes can implement any effect, and because membranes have a strong conceptual affinity with some FP concepts, it’s actually very easy to implement “co-operative revocation” using a dependently typed effect. This is best called a “permeable membrane”, because it is an opt-in system that only works if the effect is propagated.\nPlease see the Membrane example for details how Membrane is used in ocaps.\nThe clearest layman explanation of membranes is What is a Membrane? by Edward Z. Yang.\nTrustworthy Proxies: Virtualizing Objects with Invariants is an implementation of membranes in Javascript, although somehow the abstract completely avoids that word.","title":"Confining Operations with Membranes"},{"location":"/guide/designing.html","text":"","title":"Designing with Capabilities"},{"location":"/guide/designing.html#designing-with-capabilities","text":"Building up to higher level capabilities Capabilities with Domain Driven Design Capabilities and Aggregate Roots When to use Capabilities Capabilities and Side Effects Capabilities and Akka Actors Attestation (HORTON) through signed (public unsealers)","title":"Designing with Capabilities"}]}